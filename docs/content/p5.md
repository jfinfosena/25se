## Control Remoto de Motores Paso a Paso mediante MQTT y FreeRTOS

Este proyecto implementa un sistema avanzado de control remoto para motores paso a paso utilizando MQTT (Message Queuing Telemetry Transport) y FreeRTOS en Arduino. La implementación transforma un sistema básico controlado por botón físico en una solución IoT flexible y escalable. A través de mensajes JSON enviados a un broker MQTT, el sistema permite controlar dinámicamente la dirección y cantidad de pasos de dos motores (X e Y), eliminando las limitaciones del control físico y el ciclo automático predefinido. La arquitectura basada en tareas concurrentes de FreeRTOS gestiona eficientemente tanto el control de los motores como la comunicación MQTT, proporcionando además retroalimentación en tiempo real sobre el estado de los movimientos.

#### Componentes Principales:
1. **Conexión WiFi y MQTT:** El dispositivo se conecta a una red WiFi y a un broker MQTT para recibir comandos y enviar estados.
2. **Estructura `MotorParams`:** Define los parámetros de cada motor, incluyendo pines y variables actualizables por MQTT (pasos y dirección).
3. **Tarea `motorTask`:** Configura y controla un motor, ejecutando movimientos según los valores recibidos por MQTT.
4. **Tarea `mqttTask`:** Gestiona la conexión MQTT y procesa mensajes entrantes.
5. **Callback MQTT:** Parsea mensajes JSON para actualizar los parámetros de los motores y activar sus movimientos.

---

### Explicación Detallada

#### 1. **Contexto y Objetivo**
El código original usaba un botón para iniciar un ciclo predefinido de movimientos (dos fases con pasos fijos: 300/200 para motor X y 400/300 para motor Y). La modificación introduce control remoto mediante MQTT, permitiendo especificar dinámicamente la cantidad de pasos y la dirección para cada motor a través de un mensaje JSON. Esto elimina la dependencia de hardware físico (botón) y la lógica de contador, ofreciendo mayor flexibilidad.

#### 2. **Estructura del Código**

##### **Librerías**
```cpp
#include <Arduino.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>

// Configuración de WiFi
const char* ssid = "EstudiantesUSB";
const char* password = "USB367ud14nt35";

// Configuración de MQTT
const char* mqtt_server = "broker.emqx.io";
const int mqtt_port = 1883;
const char* mqtt_user = "";
const char* mqtt_password = "";

WiFiClient espClient;
PubSubClient client(espClient);

// Estructura para parámetros del motor
typedef struct {
    int stepPin;
    int dirPin;
    volatile bool* state;
    volatile int steps;    // Pasos a realizar (actualizado por MQTT)
    volatile int direction; // Dirección (0 o 1, actualizado por MQTT)
} MotorParams;

bool stateX = false;
bool stateY = false;

// Parámetros de los motores
MotorParams motorX = {4, 5, &stateX, 0, 0};
MotorParams motorY = {6, 7, &stateY, 0, 0};

// Función para conectar a WiFi
void setupWiFi() {
    Serial.println("Conectando a WiFi...");
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nConectado a WiFi");
}

// Callback para mensajes MQTT
void callback(char* topic, byte* payload, unsigned int length) {
    String message;
    for (unsigned int i = 0; i < length; i++) {
        message += (char)payload[i];
    }
    
    Serial.print("Mensaje recibido en topic [");
    Serial.print(topic);
    Serial.print("]: ");
    Serial.println(message);

    if (String(topic) == "motor/control") {
        StaticJsonDocument<200> doc;
        DeserializationError error = deserializeJson(doc, message);
        
        if (error) {
            Serial.print("Error al parsear JSON: ");
            Serial.println(error.c_str());
            client.publish("motor/status", "Error en JSON");
            return;
        }

        // Extraer pasos y dirección para motor X
        if (doc.containsKey("motorX")) {
            motorX.steps = doc["motorX"]["steps"];
            motorX.direction = doc["motorX"]["direction"];
            stateX = true;
        }

        // Extraer pasos y dirección para motor Y
        if (doc.containsKey("motorY")) {
            motorY.steps = doc["motorY"]["steps"];
            motorY.direction = doc["motorY"]["direction"];
            stateY = true;
        }

        client.publish("motor/status", "Comando recibido");
    }
}

// Reconexión a MQTT
void reconnect() {
    while (!client.connected()) {
        Serial.print("Conectando a MQTT...");
        String clientId = "ESP32Client-";
        clientId += String(random(0xffff), HEX);
        
        if (client.connect(clientId.c_str(), mqtt_user, mqtt_password)) {
            Serial.println("conectado");
            client.subscribe("motor/control");
            client.publish("motor/status", "Conectado");
        } else {
            Serial.print("falló, rc=");
            Serial.print(client.state());
            Serial.println(" intentando de nuevo en 5 segundos");
            delay(5000);
        }
    }
}

// Tarea genérica para controlar motores
void motorTask(void* pvParameters) {
    MotorParams* params = (MotorParams*)pvParameters;
    
    pinMode(params->stepPin, OUTPUT);
    pinMode(params->dirPin, OUTPUT);
    
    while (true) {
        if (*(params->state)) {
            digitalWrite(params->dirPin, params->direction);
            for (int i = 0; i < params->steps; i++) {
                digitalWrite(params->stepPin, HIGH);
                vTaskDelay(2 / portTICK_PERIOD_MS);
                digitalWrite(params->stepPin, LOW);
                vTaskDelay(2 / portTICK_PERIOD_MS);
            }
            
            *(params->state) = false;
            String status = "Motor ";
            status += (params->stepPin == motorX.stepPin) ? "X" : "Y";
            status += " detenido";
            client.publish("motor/status", status.c_str());
        }
        vTaskDelay(1 / portTICK_PERIOD_MS);
    }
}

// Tarea para manejar MQTT
void mqttTask(void* pvParameters) {
    while (true) {
        if (!client.connected()) {
            reconnect();
        }
        client.loop();
        vTaskDelay(10 / portTICK_PERIOD_MS);
    }
}

void setup() {
    Serial.begin(9600);
    pinMode(10,OUTPUT);
    setupWiFi();
    client.setServer(mqtt_server, mqtt_port);
    client.setCallback(callback);

    xTaskCreatePinnedToCore(motorTask, "MotorXTask", 2048, &motorX, 1, NULL, 0);
    xTaskCreatePinnedToCore(motorTask, "MotorYTask", 2048, &motorY, 1, NULL, 0);
    xTaskCreatePinnedToCore(mqttTask, "MqttTask", 4096, NULL, 1, NULL, 0);
}

void loop() {
    vTaskDelay(1 / portTICK_PERIOD_MS);
}
```
- Configura los pines del motor al inicio.
- Cuando el estado es `true`, mueve el motor según los valores de `steps` y `direction` recibidos.
- Al terminar, desactiva el estado y publica un mensaje indicando qué motor se detuvo.

##### **Tarea `mqttTask`**
- Mantiene la conexión MQTT y procesa los mensajes entrantes mediante `client.loop()`.

#### 4. **Setup y Loop**
- `setup()` inicializa WiFi, MQTT, y crea tareas para los motores y la comunicación.
- `loop()` mantiene el sistema en ejecución con un retardo mínimo.

#### 5. **Flujo de Operación**
1. El ESP32 se conecta a WiFi y al broker MQTT.
2. Un mensaje JSON en `"motor/control"` especifica los pasos y la dirección para uno o ambos motores.
3. `callback` actualiza los parámetros y activa los motores.
4. Cada `motorTask` ejecuta el movimiento y notifica su finalización.
5. El sistema espera nuevos comandos.

#### 6. **Diferencias con el Original**
- **Control:** MQTT reemplaza al botón físico y al contador automático.
- **Flexibilidad:** Los pasos y la dirección son dinámicos, no fijos.
- **Notificaciones:** Se envían mensajes de estado por MQTT.
- **Tareas:** Se elimina `endProcessTask`, simplificando el diseño.

---

### Ejemplo Práctico
- **Comando MQTT:**
```json
{
  "motorX": {"steps": 300, "direction": 1},
  "motorY": {"steps": 400, "direction": 0}
}
```
