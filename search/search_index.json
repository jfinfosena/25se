{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":"<p>Aqu\u00ed tienes la versi\u00f3n modificada del texto adaptada al tema \"Sistemas Embebidos\" y con la instituci\u00f3n El SENA en lugar de CESDE:</p>"},{"location":"#bienvenidos-al-submodulo-sistemas-embebidos","title":"\ud83d\ude80 Bienvenidos al Subm\u00f3dulo Sistemas Embebidos","text":"<p>\u00a1Bienvenidos a este fascinante recorrido por el universo de los sistemas embebidos! Este curso est\u00e1 dise\u00f1ado para introducirte en el desarrollo, programaci\u00f3n y aplicaci\u00f3n de sistemas embebidos, herramientas fundamentales en la industria tecnol\u00f3gica actual. Tanto si eres un principiante como si ya tienes conocimientos previos en electr\u00f3nica o programaci\u00f3n, este programa te proporcionar\u00e1 las competencias pr\u00e1cticas necesarias para sobresalir en el dise\u00f1o e implementaci\u00f3n de soluciones embebidas.</p>"},{"location":"#que-aprenderas-en-este-curso","title":"\u00bfQu\u00e9 aprender\u00e1s en este curso?","text":"<p>Este curso cubre una amplia variedad de temas esenciales y especializados, organizados en m\u00f3dulos pr\u00e1cticos:</p>"},{"location":"#fundamentos-de-sistemas-embebidos","title":"Fundamentos de Sistemas Embebidos","text":"<ul> <li>Conceptos b\u00e1sicos: Conocer\u00e1s qu\u00e9 son los sistemas embebidos, sus caracter\u00edsticas y su importancia en aplicaciones del mundo real.</li> <li>Hardware y software: Explorar\u00e1s los componentes clave como microcontroladores, sensores y actuadores, as\u00ed como el software que los controla.</li> <li>Herramientas de desarrollo: Aprender\u00e1s a configurar entornos de programaci\u00f3n como Arduino IDE, PlatformIO o Keil, optimizando tu flujo de trabajo.</li> </ul>"},{"location":"#metodologia-del-curso","title":"Metodolog\u00eda del curso","text":"<p>El curso combina aprendizaje te\u00f3rico y pr\u00e1ctico para que adquieras habilidades s\u00f3lidas:</p> <ul> <li>Clases te\u00f3ricas: Fundamentos claros sobre electr\u00f3nica, programaci\u00f3n y dise\u00f1o de sistemas embebidos.</li> <li>Laboratorios pr\u00e1cticos: Actividades guiadas para programar y probar sistemas en hardware real o simulado.</li> <li>Proyectos integradores: Dise\u00f1ar\u00e1s soluciones completas que combinen hardware, software y comunicaci\u00f3n, aplicando todo lo aprendido.</li> </ul>"},{"location":"#compromiso-de-el-sena","title":"Compromiso de El SENA","text":"<p>En El SENA, nuestro compromiso es tu desarrollo integral. Este curso no solo busca ense\u00f1arte las bases de los sistemas embebidos, sino tambi\u00e9n motivarte a innovar y aportar soluciones tecnol\u00f3gicas que transformen el entorno. Al finalizar este programa, tendr\u00e1s las competencias necesarias para dise\u00f1ar, implementar y optimizar sistemas embebidos en diversos campos de aplicaci\u00f3n.</p>"},{"location":"#embarcate-en-esta-aventura-tecnologica","title":"\u00a1Emb\u00e1rcate en esta aventura tecnol\u00f3gica!","text":"<p>Estamos entusiasmados de guiarte en este proceso de aprendizaje. Con esfuerzo y compromiso, pronto estar\u00e1s creando sistemas embebidos funcionales, resolviendo problemas reales y participando en proyectos tecnol\u00f3gicos de vanguardia.</p> <p>\u00a1Bienvenido al mundo de los sistemas embebidos!</p>"},{"location":"about/","title":"Acerca de","text":"<p>Aqu\u00ed tienes la versi\u00f3n modificada adaptada al tema \"Sistemas Embebidos\" y con El SENA en lugar de CESDE:</p> <p>El Subm\u00f3dulo Sistemas Embebidos es una iniciativa educativa del SENA, dise\u00f1ada para introducir a los estudiantes en el fascinante mundo de los sistemas embebidos, con \u00e9nfasis en herramientas clave como microcontroladores, programaci\u00f3n en C/C++ y comunicaci\u00f3n IoT. Este curso combina teor\u00eda y pr\u00e1ctica para ofrecer una base s\u00f3lida en el dise\u00f1o, desarrollo e implementaci\u00f3n de soluciones embebidas aplicables a la industria moderna.</p>"},{"location":"about/#proposito-del-curso","title":"Prop\u00f3sito del Curso","text":"<p>Este curso tiene como objetivo formar a los estudiantes en el dise\u00f1o y programaci\u00f3n de sistemas embebidos, capacit\u00e1ndolos para resolver problemas reales, desde la automatizaci\u00f3n de dispositivos hasta la integraci\u00f3n con tecnolog\u00edas IoT. Al finalizar, los participantes estar\u00e1n listos para aplicar sus habilidades en entornos profesionales, desarrollando soluciones innovadoras y participando en proyectos tecnol\u00f3gicos de alto impacto.</p> <p>\u00a1\u00danete a nosotros y comienza tu camino hacia el futuro de los sistemas embebidos!</p> <p>Espero que esta versi\u00f3n est\u00e9 a la altura de lo que necesitas. \u00bfHay algo m\u00e1s que quieras ajustar o agregar?</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"content/p0/","title":"Introducci\u00f3n a los Sistemas Embebidos","text":""},{"location":"content/p0/#que-son-los-sistemas-embebidos","title":"\u00bfQu\u00e9 son los Sistemas Embebidos?","text":"<p>Los sistemas embebidos son sistemas de computaci\u00f3n dise\u00f1ados para realizar una o varias funciones espec\u00edficas, frecuentemente en un sistema de computaci\u00f3n en tiempo real. A diferencia de las computadoras de prop\u00f3sito general, los sistemas embebidos est\u00e1n \"embebidos\" como parte de un sistema completo que incluye hardware, mec\u00e1nica y otros componentes.</p>"},{"location":"content/p0/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Prop\u00f3sito Espec\u00edfico: Dise\u00f1ados para una tarea o conjunto de tareas espec\u00edficas</li> <li>Recursos Limitados: Operan con recursos de hardware optimizados</li> <li>Tiempo Real: Muchos sistemas embebidos deben responder en tiempo real</li> <li>Alta Confiabilidad: Dise\u00f1ados para funcionar de manera continua y confiable</li> <li>Bajo Consumo: Optimizados para eficiencia energ\u00e9tica</li> </ul>"},{"location":"content/p0/#componentes-fundamentales","title":"Componentes Fundamentales","text":""},{"location":"content/p0/#1-hardware","title":"1. Hardware","text":"<ul> <li>Microcontroladores: El \"cerebro\" del sistema (Arduino, ESP32, STM32)</li> <li>Sensores: Capturan informaci\u00f3n del entorno</li> <li>Actuadores: Ejecutan acciones en el mundo f\u00edsico</li> <li>Interfaces: Permiten la comunicaci\u00f3n con otros dispositivos</li> </ul>"},{"location":"content/p0/#2-software","title":"2. Software","text":"<ul> <li>Firmware: C\u00f3digo que controla directamente el hardware</li> <li>Sistema Operativo en Tiempo Real (RTOS): Para aplicaciones m\u00e1s complejas</li> <li>Drivers: Software para controlar dispositivos espec\u00edficos</li> </ul>"},{"location":"content/p0/#herramientas-de-desarrollo","title":"Herramientas de Desarrollo","text":""},{"location":"content/p0/#1-entornos-de-desarrollo-ide","title":"1. Entornos de Desarrollo (IDE)","text":"<ul> <li>Arduino IDE</li> <li>PlatformIO</li> <li>STM32CubeIDE</li> <li>Keil \u00b5Vision</li> </ul>"},{"location":"content/p0/#2-lenguajes-de-programacion","title":"2. Lenguajes de Programaci\u00f3n","text":"<ul> <li>C/C++</li> <li>Python (para algunos sistemas)</li> <li>Ensamblador (para optimizaciones)</li> </ul>"},{"location":"content/p0/#aplicaciones-practicas","title":"Aplicaciones Pr\u00e1cticas","text":"<ol> <li> <p>Electr\u00f3nica de Consumo</p> </li> <li> <p>Electrodom\u00e9sticos inteligentes</p> </li> <li>Dispositivos IoT</li> <li> <p>Wearables</p> </li> <li> <p>Industrial</p> </li> <li> <p>Automatizaci\u00f3n</p> </li> <li>Control de procesos</li> <li> <p>Rob\u00f3tica</p> </li> <li> <p>Automotriz</p> </li> <li> <p>Sistemas de control del motor</p> </li> <li>Sistemas de seguridad</li> <li>Entretenimiento vehicular</li> </ol>"},{"location":"content/p0/#metodologia-del-curso","title":"Metodolog\u00eda del Curso","text":""},{"location":"content/p0/#1-fase-teorica","title":"1. Fase Te\u00f3rica","text":"<ul> <li>Conceptos fundamentales</li> <li>Arquitectura de sistemas</li> <li>Principios de dise\u00f1o</li> </ul>"},{"location":"content/p0/#2-fase-practica","title":"2. Fase Pr\u00e1ctica","text":"<ul> <li>Laboratorios guiados</li> <li>Proyectos pr\u00e1cticos</li> <li>Debugging y resoluci\u00f3n de problemas</li> </ul>"},{"location":"content/p1/","title":"Introducci\u00f3n a FreeRTOS y ESP32","text":""},{"location":"content/p1/#11-que-es-un-sistema-operativo-en-tiempo-real-rtos","title":"1.1 \u00bfQu\u00e9 es un Sistema Operativo en Tiempo Real (RTOS)?","text":"<ul> <li>Definici\u00f3n: Un RTOS (Real-Time Operating System) es un sistema operativo dise\u00f1ado para ejecutar aplicaciones que requieren respuestas r\u00e1pidas y predecibles.</li> <li>Caracter\u00edsticas principales:</li> <li>Determinismo: Garantiza que las tareas se ejecuten dentro de un tiempo espec\u00edfico.</li> <li>Multitarea: Permite la ejecuci\u00f3n concurrente de m\u00faltiples tareas.</li> <li>Gesti\u00f3n de recursos: Controla la memoria, CPU y otros recursos del sistema.</li> <li> <p>Sincronizaci\u00f3n: Facilita la comunicaci\u00f3n entre tareas mediante mecanismos como colas y sem\u00e1foros.</p> </li> <li> <p>Ejemplos de uso:</p> </li> <li>Sistemas embebidos (robots, drones, sensores).</li> <li>Dispositivos IoT (dom\u00f3tica, monitoreo remoto).</li> <li>Automatizaci\u00f3n industrial.</li> </ul>"},{"location":"content/p1/#12-que-es-freertos","title":"1.2 \u00bfQu\u00e9 es FreeRTOS?","text":"<ul> <li>Definici\u00f3n: FreeRTOS es un RTOS de c\u00f3digo abierto dise\u00f1ado para sistemas embebidos. Es ligero, eficiente y ampliamente utilizado en microcontroladores.</li> <li>Caracter\u00edsticas clave:</li> <li>Ligero: Ocupa pocos recursos (RAM y Flash).</li> <li>Portabilidad: Compatible con una amplia variedad de microcontroladores.</li> <li>Licencia flexible: Bajo la licencia MIT, lo que permite su uso tanto en proyectos comerciales como educativos.</li> <li> <p>Soporte comunitario: Gran comunidad de desarrolladores y documentaci\u00f3n extensa.</p> </li> <li> <p>Componentes principales:</p> </li> <li>Tareas: Unidades de trabajo que se ejecutan de forma concurrente.</li> <li>Colas: Mecanismos para transferir datos entre tareas.</li> <li>Sem\u00e1foros: Herramientas para sincronizar tareas y proteger recursos compartidos.</li> <li>Temporizadores: Para ejecutar acciones despu\u00e9s de un intervalo o de forma peri\u00f3dica.</li> </ul>"},{"location":"content/p1/#13-esp32-plataforma-ideal-para-freertos","title":"1.3 ESP32: Plataforma Ideal para FreeRTOS","text":"<ul> <li>Arquitectura Dual-Core:</li> <li>El ESP32 tiene dos n\u00facleos: PRO_CPU y APP_CPU.</li> <li>Esto permite ejecutar m\u00faltiples tareas simult\u00e1neamente, aprovechando al m\u00e1ximo el rendimiento del RTOS.</li> <li>Soporte nativo para FreeRTOS:</li> <li>FreeRTOS est\u00e1 integrado directamente en el SDK de ESP-IDF (Espressif IoT Development Framework).</li> <li>En Arduino IDE, FreeRTOS tambi\u00e9n est\u00e1 disponible de forma predeterminada cuando se trabaja con ESP32.</li> <li>Ventajas del ESP32:</li> <li>Wi-Fi y Bluetooth integrados.</li> <li>Gran cantidad de GPIOs, ADCs, DACs y perif\u00e9ricos.</li> <li>Consumo energ\u00e9tico optimizado.</li> </ul>"},{"location":"content/p1/#14-configuracion-del-entorno-de-desarrollo","title":"1.4 Configuraci\u00f3n del Entorno de Desarrollo","text":""},{"location":"content/p1/#paso-1-instalacion-de-arduino-ide","title":"Paso 1: Instalaci\u00f3n de Arduino IDE","text":"<ol> <li>Descarga e instala Arduino IDE.</li> <li>Abre Arduino IDE y verifica que est\u00e9 funcionando correctamente.</li> </ol>"},{"location":"content/p1/#paso-2-configuracion-del-soporte-para-esp32","title":"Paso 2: Configuraci\u00f3n del Soporte para ESP32","text":"<ol> <li>Abre el men\u00fa Archivo &gt; Preferencias.</li> <li>En el campo \"URLs adicionales de gestores de tarjetas\", agrega la siguiente URL:    <pre><code>https://dl.espressif.com/dl/package_esp32_index.json\n</code></pre></li> <li>Ve al men\u00fa Herramientas &gt; Placa &gt; Gestor de Tarjetas.</li> <li>Busca \"ESP32\" e instala el paquete oficial de Espressif.</li> </ol>"},{"location":"content/p1/#paso-3-verificacion-del-entorno","title":"Paso 3: Verificaci\u00f3n del Entorno","text":"<ol> <li>Conecta tu ESP32 al PC mediante USB.</li> <li>Selecciona la placa en Herramientas &gt; Placa &gt; ESP32 Dev Module.</li> <li>Carga el siguiente programa b\u00e1sico para verificar que todo funcione:</li> </ol> <pre><code>void setup() {\n  Serial.begin(115200);\n  Serial.println(\"\u00a1Hola, mundo!\");\n}\n\nvoid loop() {\n  // No hace nada\n}\n</code></pre> <ol> <li>Abre el monitor serial (Herramientas &gt; Monitor Serial) y verifica que veas el mensaje \"\u00a1Hola, mundo!\".</li> </ol>"},{"location":"content/p1/#15-funciones-basicas-de-freertos","title":"1.5 Funciones B\u00e1sicas de FreeRTOS","text":""},{"location":"content/p2/","title":"\u00bfQu\u00e9 es una tarea en FreeRTOS?","text":"<p>Una tarea en FreeRTOS es una funci\u00f3n independiente que se ejecuta en paralelo con otras tareas. Cada tarea tiene su propio contexto (variables locales, stack, etc.) y puede ser planificada para ejecutarse en un momento determinado por el planificador de FreeRTOS. Las tareas permiten dividir un sistema complejo en m\u00f3dulos m\u00e1s peque\u00f1os y manejables.</p>"},{"location":"content/p2/#caracteristicas-principales-de-las-tareas-en-freertos","title":"Caracter\u00edsticas principales de las tareas en FreeRTOS:","text":"<ol> <li>Independencia: Cada tarea opera de manera independiente, lo que facilita la modularidad del c\u00f3digo.</li> <li>Concurrencia: Varias tareas pueden ejecutarse simult\u00e1neamente (aunque en realidad se alternan r\u00e1pidamente en un solo n\u00facleo).</li> <li>Prioridades: Las tareas tienen prioridades asignadas, lo que permite que el planificador determine qu\u00e9 tarea debe ejecutarse primero.</li> <li>Sincronizaci\u00f3n: Las tareas pueden comunicarse entre s\u00ed mediante colas, sem\u00e1foros y otros mecanismos de sincronizaci\u00f3n.</li> <li>Bloqueo: Una tarea puede bloquearse (esperar) hasta que ocurra un evento espec\u00edfico (por ejemplo, recibir datos de una cola).</li> </ol>"},{"location":"content/p2/#estructura-de-una-tarea-en-freertos","title":"Estructura de una tarea en FreeRTOS","text":"<p>Una tarea en FreeRTOS se define como una funci\u00f3n que no retorna (<code>void</code>) y recibe un puntero <code>void*</code> como par\u00e1metro. Este puntero puede usarse para pasar datos iniciales a la tarea.</p> <pre><code>void vTaskFunction(void *pvParameters) {\n  // C\u00f3digo de la tarea\n  for (;;) { // Bucle infinito\n    // Realiza alguna acci\u00f3n\n    vTaskDelay(1000 / portTICK_PERIOD_MS); // Pausa la tarea durante 1 segundo\n  }\n}\n</code></pre> <ul> <li><code>vTaskFunction</code>: Es el nombre de la tarea.</li> <li><code>pvParameters</code>: Un puntero gen\u00e9rico que puede usarse para pasar datos a la tarea.</li> <li><code>for (;;)</code>: La mayor\u00eda de las tareas tienen un bucle infinito para mantenerse activas.</li> </ul>"},{"location":"content/p2/#creacion-de-una-tarea","title":"Creaci\u00f3n de una tarea","text":"<p>Para crear una tarea en FreeRTOS, se utiliza la funci\u00f3n <code>xTaskCreate()</code>. Esta funci\u00f3n configura y a\u00f1ade una nueva tarea al planificador.</p> <pre><code>xTaskCreate(\n  vTaskFunction,      // Funci\u00f3n que implementa la tarea\n  \"TaskName\",         // Nombre de la tarea (para depuraci\u00f3n)\n  STACK_SIZE,         // Tama\u00f1o del stack en palabras\n  NULL,               // Par\u00e1metros pasados a la tarea\n  TASK_PRIORITY,      // Prioridad de la tarea\n  NULL                // Manejador de la tarea (opcional)\n);\n</code></pre>"},{"location":"content/p2/#parametros-de-xtaskcreate","title":"Par\u00e1metros de <code>xTaskCreate</code>:","text":"<ol> <li>Funci\u00f3n de la tarea: La funci\u00f3n que implementa la l\u00f3gica de la tarea.</li> <li>Nombre de la tarea: Un nombre descriptivo para depuraci\u00f3n.</li> <li>Tama\u00f1o del stack: El tama\u00f1o del stack asignado a la tarea (en palabras, no bytes).</li> <li>Par\u00e1metros: Datos opcionales que se pasan a la tarea.</li> <li>Prioridad: Un n\u00famero entero que define la prioridad de la tarea (mayor n\u00famero = mayor prioridad).</li> <li>Manejador: Un puntero opcional para almacenar el identificador de la tarea.</li> </ol>"},{"location":"content/p2/#planificacion-de-tareas","title":"Planificaci\u00f3n de tareas","text":"<p>FreeRTOS utiliza un planificador preemptivo para decidir qu\u00e9 tarea debe ejecutarse en cada momento. El planificador eval\u00faa las prioridades y el estado de las tareas para tomar decisiones.</p>"},{"location":"content/p2/#estados-de-una-tarea","title":"Estados de una tarea","text":"<p>Cada tarea en FreeRTOS puede estar en uno de los siguientes estados: 1. Running: La tarea est\u00e1 siendo ejecutada actualmente. 2. Ready: La tarea est\u00e1 lista para ejecutarse pero est\u00e1 esperando su turno. 3. Blocked: La tarea est\u00e1 esperando un evento (por ejemplo, recibir datos de una cola). 4. Suspended: La tarea ha sido suspendida expl\u00edcitamente y no se ejecutar\u00e1 hasta que sea reanudada.</p>"},{"location":"content/p2/#prioridades-de-las-tareas","title":"Prioridades de las tareas","text":"<p>Las tareas en FreeRTOS tienen prioridades num\u00e9ricas. Cuanto mayor sea el n\u00famero, mayor ser\u00e1 la prioridad. Por ejemplo: - Prioridad 1: Tarea de baja prioridad. - Prioridad 10: Tarea de alta prioridad.</p> <p>El planificador siempre ejecuta la tarea de mayor prioridad que est\u00e9 en estado Ready. Si dos tareas tienen la misma prioridad, el planificador alterna entre ellas (round-robin).</p>"},{"location":"content/p2/#comunicacion-entre-tareas","title":"Comunicaci\u00f3n entre tareas","text":"<p>En sistemas multitarea, las tareas deben comunicarse entre s\u00ed para compartir datos o coordinar acciones. FreeRTOS proporciona varios mecanismos para esto:</p> <ol> <li>Colas:</li> <li>Permiten el env\u00edo de datos entre tareas.</li> <li>Ejemplo: Una tarea env\u00eda datos a una cola, y otra tarea los recibe.</li> </ol> <pre><code>xQueueSend(xQueueHandle, &amp;data, portMAX_DELAY);\nxQueueReceive(xQueueHandle, &amp;data, portMAX_DELAY);\n</code></pre> <ol> <li>Sem\u00e1foros:</li> <li>Sincronizan el acceso a recursos compartidos.</li> <li>Tipos: Binarios (mutex), contadores y mutex recursivos.</li> </ol> <pre><code>xSemaphoreTake(xSemaphore, portMAX_DELAY);\nxSemaphoreGive(xSemaphore);\n</code></pre> <ol> <li>Notificaciones directas:</li> <li>Permiten enviar se\u00f1ales simples entre tareas sin usar colas o sem\u00e1foros.</li> </ol> <pre><code>xTaskNotifyGive(xTaskHandle);\nulTaskNotifyTake(pdTRUE, portMAX_DELAY);\n</code></pre>"},{"location":"content/p2/#gestion-del-tiempo","title":"Gesti\u00f3n del tiempo","text":"<p>FreeRTOS proporciona funciones para manejar el tiempo dentro de las tareas:</p> <ol> <li>Retardo absoluto:</li> <li>Pausa la tarea durante un tiempo espec\u00edfico.</li> </ol> <pre><code>vTaskDelay(1000 / portTICK_PERIOD_MS); // Retardo de 1 segundo\n</code></pre> <ol> <li>Retardo relativo:</li> <li>Pausa la tarea hasta un tiempo absoluto.</li> </ol> <pre><code>TickType_t xLastWakeTime = xTaskGetTickCount();\nvTaskDelayUntil(&amp;xLastWakeTime, 1000 / portTICK_PERIOD_MS);\n</code></pre>"},{"location":"content/p2/#suspension-y-eliminacion-de-tareas","title":"Suspensi\u00f3n y eliminaci\u00f3n de tareas","text":"<ol> <li>Suspender una tarea:</li> <li>Detiene temporalmente la ejecuci\u00f3n de una tarea.</li> </ol> <pre><code>vTaskSuspend(xTaskHandle);\n</code></pre> <ol> <li>Reanudar una tarea:</li> <li>Reactiva una tarea suspendida.</li> </ol> <pre><code>vTaskResume(xTaskHandle);\n</code></pre> <ol> <li>Eliminar una tarea:</li> <li>Libera los recursos asociados a una tarea.</li> </ol> <pre><code>vTaskDelete(xTaskHandle);\n</code></pre>"},{"location":"content/p2/#depuracion-de-tareas","title":"Depuraci\u00f3n de tareas","text":"<p>FreeRTOS incluye herramientas \u00fatiles para depurar tareas:</p> <ol> <li><code>uxTaskGetStackHighWaterMark()</code>:</li> <li>Devuelve la cantidad m\u00ednima de stack libre que ha tenido una tarea. \u00datil para ajustar el tama\u00f1o del stack.</li> </ol> <pre><code>UBaseType_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);\n</code></pre> <ol> <li><code>vTaskList()</code>:</li> <li>Genera una lista de todas las tareas y sus estados.</li> </ol> <pre><code>char pcWriteBuffer[256];\nvTaskList(pcWriteBuffer);\nSerial.println(pcWriteBuffer);\n</code></pre>"},{"location":"content/p2/#ejemplo-1-tareas-en-freertos","title":"Ejemplo 1: Tareas en FreeRTOS","text":"<p>Este c\u00f3digo es un ejemplo de c\u00f3mo utilizar FreeRTOS en un entorno de Arduino para crear y manejar tareas multitarea (tambi\u00e9n conocidas como \"hilos\" o \"threads\"). FreeRTOS es un sistema operativo en tiempo real (RTOS) que permite ejecutar m\u00faltiples tareas de manera concurrente en microcontroladores. A continuaci\u00f3n, te explico cada parte del c\u00f3digo:</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;freertos/FreeRTOS.h&gt;\n#include &lt;freertos/task.h&gt;\n\n// Tarea 1: Imprime \"Hola\" cada 1 segundo\nvoid TaskHello(void *pvParameters) {\n  while (1) {\n    Serial.println(\"Hola\");\n    vTaskDelay(1000 / portTICK_PERIOD_MS);\n  }\n}\n\n// Tarea 2: Imprime \"Mundo\" cada 2 segundos\nvoid TaskWorld(void *pvParameters) {\n  while (1) {\n    Serial.println(\"Mundo\");\n    vTaskDelay(2000 / portTICK_PERIOD_MS);\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Crear las tareas\n  xTaskCreate(TaskHello, \"HelloTask\", 2048, NULL, 1, NULL);\n  xTaskCreate(TaskWorld, \"WorldTask\", 2048, NULL, 1, NULL);\n}\n\nvoid loop() {\n  // No hace nada, todo se maneja en las tareas\n}\n</code></pre>"},{"location":"content/p2/#1-inclusion-de-bibliotecas","title":"1. Inclusi\u00f3n de bibliotecas","text":"<p><pre><code>#include &lt;Arduino.h&gt;\n#include &lt;freertos/FreeRTOS.h&gt;\n#include &lt;freertos/task.h&gt;\n</code></pre> - <code>Arduino.h</code>: Es la biblioteca principal de Arduino, necesaria para usar funciones como <code>Serial.begin()</code> y <code>Serial.println()</code>. - <code>freertos/FreeRTOS.h</code>: Es la biblioteca principal de FreeRTOS, que proporciona las funciones y estructuras necesarias para crear y manejar tareas. - <code>freertos/task.h</code>: Es una parte de FreeRTOS que se enfoca en la creaci\u00f3n y gesti\u00f3n de tareas.</p>"},{"location":"content/p2/#2-definicion-de-tareas","title":"2. Definici\u00f3n de tareas","text":""},{"location":"content/p2/#tarea-1-taskhello","title":"Tarea 1: <code>TaskHello</code>","text":"<p><pre><code>void TaskHello(void *pvParameters) {\n  while (1) {\n    Serial.println(\"Hola\");\n    vTaskDelay(1000 / portTICK_PERIOD_MS);\n  }\n}\n</code></pre> - <code>TaskHello</code>: Es una funci\u00f3n que representa una tarea. Esta tarea imprime \"Hola\" en el monitor serie cada 1 segundo. - <code>while (1)</code>: Es un bucle infinito que asegura que la tarea se ejecute continuamente. - <code>Serial.println(\"Hola\")</code>: Imprime \"Hola\" en el monitor serie. - <code>vTaskDelay(1000 / portTICK_PERIOD_MS)</code>: Pausa la tarea durante 1000 milisegundos (1 segundo). <code>portTICK_PERIOD_MS</code> es una constante que convierte milisegundos en \"ticks\" del sistema (unidades de tiempo de FreeRTOS).</p>"},{"location":"content/p2/#tarea-2-taskworld","title":"Tarea 2: <code>TaskWorld</code>","text":"<p><pre><code>void TaskWorld(void *pvParameters) {\n  while (1) {\n    Serial.println(\"Mundo\");\n    vTaskDelay(2000 / portTICK_PERIOD_MS);\n  }\n}\n</code></pre> - <code>TaskWorld</code>: Es otra tarea que imprime \"Mundo\" en el monitor serie cada 2 segundos. - <code>vTaskDelay(2000 / portTICK_PERIOD_MS)</code>: Pausa la tarea durante 2000 milisegundos (2 segundos).</p>"},{"location":"content/p2/#3-funcion-setup","title":"3. Funci\u00f3n <code>setup()</code>","text":"<p><pre><code>void setup() {\n  Serial.begin(115200);\n\n  // Crear las tareas\n  xTaskCreate(TaskHello, \"HelloTask\", 2048, NULL, 1, NULL);\n  xTaskCreate(TaskWorld, \"WorldTask\", 2048, NULL, 1, NULL);\n}\n</code></pre> - <code>Serial.begin(115200)</code>: Inicializa la comunicaci\u00f3n serial a una velocidad de 115200 baudios para poder ver los mensajes en el monitor serie. - <code>xTaskCreate()</code>: Es una funci\u00f3n de FreeRTOS que crea una nueva tarea. Tiene los siguientes par\u00e1metros:   1. Funci\u00f3n de la tarea: <code>TaskHello</code> o <code>TaskWorld</code>.   2. Nombre de la tarea: Un nombre descriptivo para la tarea (por ejemplo, \"HelloTask\").   3. Tama\u00f1o de la pila: La cantidad de memoria asignada a la tarea (en este caso, 2048 bytes).   4. Par\u00e1metros de la tarea: <code>NULL</code> porque no se pasan par\u00e1metros adicionales.   5. Prioridad de la tarea: Un n\u00famero que indica la prioridad de la tarea (en este caso, 1).   6. Manejador de la tarea: <code>NULL</code> porque no se necesita un manejador para esta tarea.</p>"},{"location":"content/p2/#4-funcion-loop","title":"4. Funci\u00f3n <code>loop()</code>","text":"<p><pre><code>void loop() {\n  // No hace nada, todo se maneja en las tareas\n}\n</code></pre> - <code>loop()</code>: En este caso, la funci\u00f3n <code>loop()</code> est\u00e1 vac\u00eda porque todo el trabajo se realiza en las tareas creadas con FreeRTOS. FreeRTOS se encarga de gestionar la ejecuci\u00f3n de las tareas.</p>"},{"location":"content/p2/#5-funcionamiento-del-programa","title":"5. Funcionamiento del programa","text":"<ul> <li>Cuando el programa se ejecuta, FreeRTOS crea dos tareas: <code>TaskHello</code> y <code>TaskWorld</code>.</li> <li>Ambas tareas se ejecutan de manera concurrente, pero FreeRTOS gestiona el tiempo de CPU entre ellas.</li> <li><code>TaskHello</code> imprime \"Hola\" cada 1 segundo, y <code>TaskWorld</code> imprime \"Mundo\" cada 2 segundos.</li> <li>Como las tareas tienen la misma prioridad (1), FreeRTOS alterna entre ellas de manera equitativa.</li> </ul>"},{"location":"content/p2/#ejemplo-2-tareas-en-freertos","title":"Ejemplo 2: Tareas en FreeRTOS","text":"<p>Este c\u00f3digo es un ejemplo avanzado de c\u00f3mo utilizar FreeRTOS en un entorno de Arduino, espec\u00edficamente en un microcontrolador ESP32 (o compatible), para manejar m\u00faltiples tareas de manera concurrente. Adem\u00e1s, utiliza pines espec\u00edficos para controlar LEDs y muestra c\u00f3mo ejecutar tareas en n\u00facleos espec\u00edficos del procesador. A continuaci\u00f3n, te explico cada parte del c\u00f3digo:</p> <pre><code>#include &lt;Arduino.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n\nint Led1 = 7;\nint Led2 = 6;\nint contador = 0;\n\n\nvoid tareaControlLed1(void *pvParameters) {\n  while (true) {\n    digitalWrite(Led1, HIGH);\n    vTaskDelay(200 / portTICK_PERIOD_MS);\n    digitalWrite(Led1, LOW);\n    vTaskDelay(200 / portTICK_PERIOD_MS);\n  }\n}\n\nvoid tareaControlLed2(void *pvParameters) {\n  while (true) {\n    digitalWrite(Led2, HIGH);\n    vTaskDelay(500 / portTICK_PERIOD_MS);\n    digitalWrite(Led2, LOW);\n    vTaskDelay(500 / portTICK_PERIOD_MS);\n  }\n}\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  pinMode(Led1, OUTPUT);\n  pinMode(Led2, OUTPUT);\n  xTaskCreatePinnedToCore(tareaControlLed1, \"tareaLed1\", 2048, NULL, 1, NULL, 0);\n  xTaskCreatePinnedToCore(tareaControlLed2, \"tareaLed2\", 2048, NULL, 1, NULL, 0);\n}\n\nvoid loop() {\n  Serial.println(contador);\n  contador++;\n  vTaskDelay(1 / portTICK_PERIOD_MS);\n}\n</code></pre>"},{"location":"content/p2/#1-inclusion-de-bibliotecas_1","title":"1. Inclusi\u00f3n de bibliotecas","text":"<p><pre><code>#include &lt;Arduino.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n</code></pre> - <code>Arduino.h</code>: Es la biblioteca principal de Arduino, necesaria para usar funciones como <code>Serial.begin()</code>, <code>pinMode()</code> y <code>digitalWrite()</code>. - <code>freertos/FreeRTOS.h</code>: Es la biblioteca principal de FreeRTOS, que proporciona las funciones y estructuras necesarias para crear y manejar tareas. - <code>freertos/task.h</code>: Es una parte de FreeRTOS que se enfoca en la creaci\u00f3n y gesti\u00f3n de tareas.</p>"},{"location":"content/p2/#2-definicion-de-variables-globales","title":"2. Definici\u00f3n de variables globales","text":"<p><pre><code>int Led1 = 7;\nint Led2 = 6;\nint contador = 0;\n</code></pre> - <code>Led1</code> y <code>Led2</code>: Son los pines digitales donde est\u00e1n conectados los LEDs. En este caso, el LED 1 est\u00e1 en el pin 7 y el LED 2 en el pin 6. - <code>contador</code>: Es una variable global que se incrementa en la funci\u00f3n <code>loop()</code> y se imprime en el monitor serie.</p>"},{"location":"content/p2/#3-definicion-de-tareas","title":"3. Definici\u00f3n de tareas","text":""},{"location":"content/p2/#tarea-1-tareacontrolled1","title":"Tarea 1: <code>tareaControlLed1</code>","text":"<p><pre><code>void tareaControlLed1(void *pvParameters) {\n  while (true) {\n    digitalWrite(Led1, HIGH);\n    vTaskDelay(200 / portTICK_PERIOD_MS);\n    digitalWrite(Led1, LOW);\n    vTaskDelay(200 / portTICK_PERIOD_MS);\n  }\n}\n</code></pre> - <code>tareaControlLed1</code>: Es una tarea que controla el LED 1. - <code>digitalWrite(Led1, HIGH)</code>: Enciende el LED 1. - <code>vTaskDelay(200 / portTICK_PERIOD_MS)</code>: Pausa la tarea durante 200 milisegundos (0.2 segundos). - <code>digitalWrite(Led1, LOW)</code>: Apaga el LED 1. - <code>vTaskDelay(200 / portTICK_PERIOD_MS)</code>: Pausa la tarea otros 200 milisegundos. - Este ciclo se repite indefinidamente, haciendo que el LED 1 parpadee cada 400 ms (200 ms encendido y 200 ms apagado).</p>"},{"location":"content/p2/#tarea-2-tareacontrolled2","title":"Tarea 2: <code>tareaControlLed2</code>","text":"<p><pre><code>void tareaControlLed2(void *pvParameters) {\n  while (true) {\n    digitalWrite(Led2, HIGH);\n    vTaskDelay(500 / portTICK_PERIOD_MS);\n    digitalWrite(Led2, LOW);\n    vTaskDelay(500 / portTICK_PERIOD_MS);\n  }\n}\n</code></pre> - <code>tareaControlLed2</code>: Es una tarea que controla el LED 2. - <code>digitalWrite(Led2, HIGH)</code>: Enciende el LED 2. - <code>vTaskDelay(500 / portTICK_PERIOD_MS)</code>: Pausa la tarea durante 500 milisegundos (0.5 segundos). - <code>digitalWrite(Led2, LOW)</code>: Apaga el LED 2. - <code>vTaskDelay(500 / portTICK_PERIOD_MS)</code>: Pausa la tarea otros 500 milisegundos. - Este ciclo se repite indefinidamente, haciendo que el LED 2 parpadee cada 1000 ms (500 ms encendido y 500 ms apagado).</p>"},{"location":"content/p2/#4-funcion-setup","title":"4. Funci\u00f3n <code>setup()</code>","text":"<p><pre><code>void setup() {\n  Serial.begin(115200);\n  pinMode(Led1, OUTPUT);\n  pinMode(Led2, OUTPUT);\n  xTaskCreatePinnedToCore(tareaControlLed1, \"tareaLed1\", 2048, NULL, 1, NULL, 0);\n  xTaskCreatePinnedToCore(tareaControlLed2, \"tareaLed2\", 2048, NULL, 1, NULL, 0);\n}\n</code></pre> - <code>Serial.begin(115200)</code>: Inicializa la comunicaci\u00f3n serial a una velocidad de 115200 baudios para poder ver los mensajes en el monitor serie. - <code>pinMode(Led1, OUTPUT)</code>: Configura el pin <code>Led1</code> como salida. - <code>pinMode(Led2, OUTPUT)</code>: Configura el pin <code>Led2</code> como salida. - <code>xTaskCreatePinnedToCore()</code>: Es una funci\u00f3n de FreeRTOS que crea una tarea y la asigna a un n\u00facleo espec\u00edfico del procesador (en este caso, el n\u00facleo 0). Tiene los siguientes par\u00e1metros:   1. Funci\u00f3n de la tarea: <code>tareaControlLed1</code> o <code>tareaControlLed2</code>.   2. Nombre de la tarea: Un nombre descriptivo para la tarea (por ejemplo, \"tareaLed1\").   3. Tama\u00f1o de la pila: La cantidad de memoria asignada a la tarea (en este caso, 2048 bytes).   4. Par\u00e1metros de la tarea: <code>NULL</code> porque no se pasan par\u00e1metros adicionales.   5. Prioridad de la tarea: Un n\u00famero que indica la prioridad de la tarea (en este caso, 1).   6. Manejador de la tarea: <code>NULL</code> porque no se necesita un manejador para esta tarea.   7. N\u00facleo del procesador: El n\u00facleo en el que se ejecutar\u00e1 la tarea (en este caso, 0).</p>"},{"location":"content/p2/#5-funcion-loop","title":"5. Funci\u00f3n <code>loop()</code>","text":"<p><pre><code>void loop() {\n  Serial.println(contador);\n  contador++;\n  vTaskDelay(1 / portTICK_PERIOD_MS);\n}\n</code></pre> - <code>Serial.println(contador)</code>: Imprime el valor de la variable <code>contador</code> en el monitor serie. - <code>contador++</code>: Incrementa el valor de <code>contador</code> en 1. - <code>vTaskDelay(1 / portTICK_PERIOD_MS)</code>: Pausa la tarea durante 1 milisegundo. Esto permite que otras tareas se ejecuten y evita que <code>loop()</code> consuma todo el tiempo de CPU.</p>"},{"location":"content/p2/#6-funcionamiento-del-programa","title":"6. Funcionamiento del programa","text":"<ul> <li>Cuando el programa se ejecuta, FreeRTOS crea dos tareas: <code>tareaControlLed1</code> y <code>tareaControlLed2</code>, y las asigna al n\u00facleo 0.</li> <li>Ambas tareas se ejecutan de manera concurrente, pero FreeRTOS gestiona el tiempo de CPU entre ellas.</li> <li><code>tareaControlLed1</code> hace parpadear el LED 1 cada 400 ms.</li> <li><code>tareaControlLed2</code> hace parpadear el LED 2 cada 1000 ms.</li> <li>La funci\u00f3n <code>loop()</code> imprime el valor de <code>contador</code> en el monitor serie y lo incrementa cada 1 ms.</li> </ul>"},{"location":"content/p2/#7-salida-esperada","title":"7. Salida esperada","text":"<ul> <li>Monitor serie: Ver\u00e1s un incremento r\u00e1pido del valor de <code>contador</code> (cada 1 ms).</li> <li>LED 1: Parpadea cada 400 ms.</li> <li>LED 2: Parpadea cada 1000 ms.</li> </ul>"},{"location":"content/p2/#8-consideraciones-adicionales","title":"8. Consideraciones adicionales","text":"<ul> <li>N\u00facleos del procesador: En el ESP32, hay dos n\u00facleos (0 y 1). En este caso, ambas tareas se ejecutan en el n\u00facleo 0, pero podr\u00edas asignar una tarea al n\u00facleo 1 si lo deseas.</li> <li>Prioridad de tareas: Ambas tareas tienen la misma prioridad (1), por lo que FreeRTOS alterna entre ellas de manera equitativa.</li> <li>Uso de memoria: Cada tarea consume memoria para su pila. Aseg\u00farate de asignar suficiente memoria (en este caso, 2048 bytes por tarea).</li> </ul>"},{"location":"content/p3/","title":"Control de Motores Paso a Paso con FreeRTOS y ESP32","text":""},{"location":"content/p3/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta sesi\u00f3n, aprenderemos a controlar dos motores paso a paso de forma simult\u00e1nea utilizando FreeRTOS en un ESP32 DevKit Mini y el driver A4988. Este proyecto demuestra el poder del sistema operativo en tiempo real para manejar m\u00faltiples tareas concurrentes.</p>"},{"location":"content/p3/#componentes-necesarios","title":"Componentes Necesarios","text":"<ul> <li>1x ESP32 DevKit Mini</li> <li>2x Drivers A4988</li> <li>2x Motores paso a paso (compatible con A4988)</li> <li>Fuente de alimentaci\u00f3n (12V-24V dependiendo de los motores)</li> <li>Cables de conexi\u00f3n</li> </ul>"},{"location":"content/p3/#conexiones-del-hardware","title":"Conexiones del Hardware","text":""},{"location":"content/p3/#configuracion-del-driver-a4988","title":"Configuraci\u00f3n del Driver A4988","text":"<p>Cada driver A4988 requiere las siguientes conexiones:</p> <p>Motor 1: - STEP -&gt; GPIO 25 - DIR -&gt; GPIO 26 - ENABLE -&gt; GPIO 27 - MS1, MS2, MS3 -&gt; Configuraci\u00f3n de microstepping (opcional) - VMOT -&gt; 12V-24V (Alimentaci\u00f3n del motor) - GND -&gt; GND com\u00fan</p> <p>Motor 2: - STEP -&gt; GPIO 32 - DIR -&gt; GPIO 33 - ENABLE -&gt; GPIO 14 - MS1, MS2, MS3 -&gt; Configuraci\u00f3n de microstepping (opcional) - VMOT -&gt; 12V-24V (Alimentaci\u00f3n del motor) - GND -&gt; GND com\u00fan</p> <p></p>"},{"location":"content/p3/#implementacion-con-freertos","title":"Implementaci\u00f3n con FreeRTOS","text":""},{"location":"content/p3/#codigo-base","title":"C\u00f3digo Base","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n\n// Definici\u00f3n de pines para Motor X\n#define MOTOR_X_STEP_PIN 9\n#define MOTOR_X_DIR_PIN 8\n#define MOTOR_X_ENABLE_PIN 5\n\n// Definici\u00f3n de pines para Motor Y\n#define MOTOR_Y_STEP_PIN 7\n#define MOTOR_Y_DIR_PIN 6\n#define MOTOR_Y_ENABLE_PIN 4\n\n// Pin para el bot\u00f3n de inicio\n#define START_BUTTON_PIN 2\n\n// Variables globales\nvolatile bool startMovement = false;\n\n// Tarea para el motor X (400 pasos)\nvoid motorXTask(void *pvParameters) {\n  // Configuraci\u00f3n de pines\n  pinMode(MOTOR_X_STEP_PIN, OUTPUT);\n  pinMode(MOTOR_X_DIR_PIN, OUTPUT);\n  pinMode(MOTOR_X_ENABLE_PIN, OUTPUT);\n\n  digitalWrite(MOTOR_X_ENABLE_PIN, LOW); // Habilitar el motor\n  digitalWrite(MOTOR_X_DIR_PIN, HIGH);   // Direcci\u00f3n horaria\n\n  while (1) {\n    if (startMovement) {\n      // Realizar 400 pasos\n      for (int i = 0; i &lt; 400; i++) {\n        digitalWrite(MOTOR_X_STEP_PIN, HIGH);\n        delayMicroseconds(500);\n        digitalWrite(MOTOR_X_STEP_PIN, LOW);\n        delayMicroseconds(500);\n        vTaskDelay(5 / portTICK_PERIOD_MS); // Velocidad moderada\n      }\n      startMovement = false; // Detener despu\u00e9s de completar los pasos\n    }\n    vTaskDelay(10 / portTICK_PERIOD_MS);\n  }\n}\n\n// Tarea para el motor Y (200 pasos)\nvoid motorYTask(void *pvParameters) {\n  // Configuraci\u00f3n de pines\n  pinMode(MOTOR_Y_STEP_PIN, OUTPUT);\n  pinMode(MOTOR_Y_DIR_PIN, OUTPUT);\n  pinMode(MOTOR_Y_ENABLE_PIN, OUTPUT);\n\n  digitalWrite(MOTOR_Y_ENABLE_PIN, LOW); // Habilitar el motor\n  digitalWrite(MOTOR_Y_DIR_PIN, HIGH);   // Direcci\u00f3n horaria\n\n  while (1) {\n    if (startMovement) {\n      // Realizar 200 pasos\n      for (int i = 0; i &lt; 200; i++) {\n        digitalWrite(MOTOR_Y_STEP_PIN, HIGH);\n        delayMicroseconds(500);\n        digitalWrite(MOTOR_Y_STEP_PIN, LOW);\n        delayMicroseconds(500);\n        vTaskDelay(5 / portTICK_PERIOD_MS); // Velocidad moderada\n      }\n      startMovement = false; // Detener despu\u00e9s de completar los pasos\n    }\n    vTaskDelay(10 / portTICK_PERIOD_MS);\n  }\n}\n\nvoid setup() {\n  // Configurar el pin del bot\u00f3n\n  pinMode(START_BUTTON_PIN, INPUT_PULLUP);\n\n  // Crear tareas para cada motor\n  xTaskCreatePinnedToCore(\n    motorXTask,\n    \"MotorXTask\",\n    2048,\n    NULL,\n    1,\n    NULL,\n    0\n  );\n\n  xTaskCreatePinnedToCore(\n    motorYTask,\n    \"MotorYTask\",\n    2048,\n    NULL,\n    1,\n    NULL,\n    0\n  );\n}\n\nvoid loop() {\n  // Verificar el bot\u00f3n de inicio\n  if (digitalRead(START_BUTTON_PIN) == LOW) {\n    startMovement = true;\n    delay(500); // Debounce\n  }\n  vTaskDelay(10 / portTICK_PERIOD_MS);\n}\n</code></pre>"},{"location":"content/p3/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ol> <li>Configuraci\u00f3n Inicial:</li> <li>Definimos los pines para cada motor</li> <li>Creamos una estructura <code>MotorParams</code> para manejar los par\u00e1metros de cada motor</li> <li> <p>Inicializamos colas para la comunicaci\u00f3n entre tareas</p> </li> <li> <p>Tareas de FreeRTOS:</p> </li> <li>Cada motor se ejecuta en su propia tarea</li> <li>Las tareas se asignan a diferentes n\u00facleos del ESP32 para verdadero paralelismo</li> <li> <p>Utilizamos <code>vTaskDelay</code> para controlar la velocidad de los motores</p> </li> <li> <p>Control de Motores:</p> </li> <li>Los motores se pueden controlar de forma independiente</li> <li>La velocidad y direcci\u00f3n se pueden modificar en tiempo real</li> <li>El sistema es escalable y puede manejar diferentes perfiles de movimiento</li> </ol>"},{"location":"content/p3/#ventajas-de-usar-freertos","title":"Ventajas de usar FreeRTOS","text":"<ol> <li>Multitarea Real:</li> <li>Cada motor se ejecuta de forma independiente</li> <li> <p>No hay bloqueos entre los motores</p> </li> <li> <p>Mejor Gesti\u00f3n de Recursos:</p> </li> <li>FreeRTOS maneja la programaci\u00f3n de tareas</li> <li> <p>Aprovechamiento de ambos n\u00facleos del ESP32</p> </li> <li> <p>Sincronizaci\u00f3n:</p> </li> <li>Posibilidad de sincronizar movimientos entre motores</li> <li>Comunicaci\u00f3n eficiente entre tareas</li> </ol>"},{"location":"content/p3/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":""},{"location":"content/p3/#ejercicio-modificacion-del-control-de-motores","title":"Ejercicio: Modificaci\u00f3n del Control de Motores","text":"<p>Modifica el programa base para implementar las siguientes funcionalidades:</p> <ol> <li>Secuencia Alternada:</li> <li>Modifica el programa para que los motores se muevan de forma alternada</li> <li>El Motor X debe realizar 200 pasos</li> <li> <p>El Motor Y debe realizar 400 pasos (invirtiendo los valores originales) </p> </li> <li> <p>Control de Direcci\u00f3n:</p> </li> <li>Agrega un segundo bot\u00f3n (GPIO 15) para controlar la direcci\u00f3n de los motores</li> <li>Cuando el bot\u00f3n de direcci\u00f3n est\u00e9 presionado, ambos motores deben girar en sentido antihorario</li> <li>Cuando el bot\u00f3n de direcci\u00f3n est\u00e9 liberado, los motores deben girar en sentido horario</li> </ol>"},{"location":"content/p3/#entregables","title":"Entregables","text":"<ol> <li>C\u00f3digo modificado con comentarios explicando los cambios realizados</li> <li>Breve explicaci\u00f3n de c\u00f3mo se implement\u00f3 cada funcionalidad</li> <li>Captura de video mostrando el funcionamiento del sistema modificado</li> </ol>"},{"location":"content/p4/","title":"Control Concurrente de Motores Paso a Paso con FreeRTOS en Arduino","text":"<p>El c\u00f3digo es un programa para Arduino que utiliza el sistema operativo en tiempo real FreeRTOS para controlar dos motores paso a paso (X e Y) mediante tareas concurrentes. Los motores se mueven en una direcci\u00f3n fija (1) con un n\u00famero de pasos predefinido que cambia seg\u00fan un contador (<code>counterMoves</code>). El sistema se activa con un bot\u00f3n y muestra mensajes por el puerto serial cuando los motores terminan su movimiento. Cada motor tiene su propia tarea que tambi\u00e9n configura sus pines, mientras que tareas adicionales manejan el bot\u00f3n y el control del proceso.</p>"},{"location":"content/p4/#componentes-principales","title":"Componentes Principales:","text":"<ol> <li>Estructura <code>MotorParams</code>: Define los par\u00e1metros de cada motor (pines de paso y direcci\u00f3n, pasos para dos movimientos distintos, y un puntero a su estado).</li> <li>Variables Globales: Incluyen pines del bot\u00f3n, estados de los motores, un indicador de inicio y un contador de movimientos.</li> <li>Tarea <code>motorTask</code>: Controla un motor, configura sus pines y ejecuta el movimiento seg\u00fan el estado y el contador.</li> <li>Tarea <code>buttonTask</code>: Detecta la presi\u00f3n del bot\u00f3n para iniciar el movimiento de los motores.</li> <li>Tarea <code>endProcessTask</code>: Monitorea el fin del movimiento de los motores y reinicia el ciclo.</li> <li>Setup y Loop: Configura el sistema y mantiene el programa en ejecuci\u00f3n.</li> </ol>"},{"location":"content/p4/#explicacion-detallada","title":"Explicaci\u00f3n Detallada","text":""},{"location":"content/p4/#1-inclusion-de-librerias-y-definiciones","title":"1. Inclusi\u00f3n de Librer\u00edas y Definiciones","text":"<p><pre><code>#include &lt;Arduino.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n</code></pre> - Se incluyen las librer\u00edas necesarias para usar funciones de Arduino y FreeRTOS, que permite la ejecuci\u00f3n de tareas concurrentes en el microcontrolador.</p>"},{"location":"content/p4/#2-estructura-motorparams","title":"2. Estructura <code>MotorParams</code>","text":"<p><pre><code>typedef struct {\n    int stepPin;        // Pin para pulsos de paso\n    int dirPin;         // Pin para direcci\u00f3n\n    int steps1;         // Pasos para el primer movimiento\n    int steps2;         // Pasos para el segundo movimiento\n    volatile bool* state; // Puntero al estado del motor\n} MotorParams;\n</code></pre> - Define una estructura que agrupa los par\u00e1metros de cada motor. - <code>volatile bool* state</code> es un puntero a una variable booleana que indica si el motor debe moverse, marcada como <code>volatile</code> porque es accedida por m\u00faltiples tareas.</p>"},{"location":"content/p4/#3-variables-globales","title":"3. Variables Globales","text":"<p><pre><code>int btnStart = 2;         // Pin del bot\u00f3n\nbool stateX = false;      // Estado del motor X\nbool stateY = false;      // Estado del motor Y\nbool start = false;       // Indicador de inicio del proceso\nint counterMoves = 0;     // Contador de ciclos de movimiento\n\nMotorParams motorX = {9, 8, 300, 200, &amp;stateX};  // Configuraci\u00f3n del motor X\nMotorParams motorY = {7, 6, 400, 300, &amp;stateY};  // Configuraci\u00f3n del motor Y\n</code></pre> - <code>btnStart</code>: Pin del bot\u00f3n que inicia el movimiento. - <code>stateX</code> y <code>stateY</code>: Controlan si cada motor debe moverse. - <code>start</code>: Indica que el proceso est\u00e1 activo. - <code>counterMoves</code>: Determina cu\u00e1ntos pasos dar en cada ciclo (0 o 1). - <code>motorX</code> y <code>motorY</code>: Instancias de <code>MotorParams</code> con valores espec\u00edficos para cada motor.</p>"},{"location":"content/p4/#4-tarea-motortask","title":"4. Tarea <code>motorTask</code>","text":"<p><pre><code>void motorTask(void* pvParameters) {\n    MotorParams* params = (MotorParams*)pvParameters;\n\n    pinMode(params-&gt;stepPin, OUTPUT);\n    pinMode(params-&gt;dirPin, OUTPUT);\n\n    while (true) {\n        if (*(params-&gt;state)) {\n            int steps = (counterMoves == 0) ? params-&gt;steps1 : params-&gt;steps2;\n\n            digitalWrite(params-&gt;dirPin, 1);\n            for (int i = 0; i &lt; steps; i++) {\n                digitalWrite(params-&gt;stepPin, HIGH);\n                vTaskDelay(10 / portTICK_PERIOD_MS);\n                digitalWrite(params-&gt;stepPin, LOW);\n                vTaskDelay(10 / portTICK_PERIOD_MS);\n            }\n\n            *(params-&gt;state) = false;\n        }\n        vTaskDelay(1 / portTICK_PERIOD_MS);\n    }\n}\n</code></pre> - Par\u00e1metros: Recibe un puntero a <code>MotorParams</code> a trav\u00e9s de <code>pvParameters</code>. - Configuraci\u00f3n: Configura <code>stepPin</code> y <code>dirPin</code> como salidas al inicio de la tarea. - Bucle Infinito:    - Si el estado del motor (<code>*(params-&gt;state)</code>) es <code>true</code>, ejecuta el movimiento.   - Selecciona los pasos (<code>steps1</code> o <code>steps2</code>) seg\u00fan <code>counterMoves</code>.   - Establece la direcci\u00f3n en 1 (<code>digitalWrite(params-&gt;dirPin, 1)</code>).   - Genera pulsos en <code>stepPin</code> (HIGH y LOW) con retardos de 10 ms entre ellos.   - Una vez completado, desactiva el estado del motor. - Retardo: Pausa de 1 ms entre iteraciones para no saturar el n\u00facleo.</p>"},{"location":"content/p4/#5-tarea-buttontask","title":"5. Tarea <code>buttonTask</code>","text":"<p><pre><code>void buttonTask(void* pvParameters) {\n    while (true) {\n        if (digitalRead(btnStart) == LOW) {\n            start = true;\n            stateX = true;\n            stateY = true;\n        }\n        vTaskDelay(1 / portTICK_PERIOD_MS);\n    }\n}\n</code></pre> - Monitorea el bot\u00f3n conectado al pin <code>btnStart</code>. - Cuando se presiona (nivel LOW debido a <code>INPUT_PULLUP</code>), activa <code>start</code> y los estados de ambos motores. - Retardo de 1 ms para no sobrecargar el procesador.</p>"},{"location":"content/p4/#6-tarea-endprocesstask","title":"6. Tarea <code>endProcessTask</code>","text":"<p><pre><code>void endProcessTask(void* pvParameters) {\n    while (true) {\n        if (start &amp;&amp; !stateX &amp;&amp; !stateY) {\n            Serial.println(\"Motor XY off\");\n            vTaskDelay(2000 / portTICK_PERIOD_MS);\n            counterMoves++;\n            stateX = true;\n            stateY = true;\n        }\n        vTaskDelay(1 / portTICK_PERIOD_MS);\n    }\n}\n</code></pre> - Verifica si el proceso est\u00e1 activo (<code>start</code>) y ambos motores han terminado (<code>!stateX &amp;&amp; !stateY</code>). - Imprime un mensaje, espera 2 segundos, incrementa <code>counterMoves</code>, y reactiva los motores. - Retardo de 1 ms entre iteraciones.</p>"},{"location":"content/p4/#7-funcion-setup","title":"7. Funci\u00f3n <code>setup</code>","text":"<p><pre><code>void setup() {\n    Serial.begin(9600);\n    pinMode(btnStart, INPUT_PULLUP);\n\n    xTaskCreatePinnedToCore(motorTask, \"MotorXTask\", 2048, &amp;motorX, 1, NULL, 0);\n    xTaskCreatePinnedToCore(motorTask, \"MotorYTask\", 2048, &amp;motorY, 1, NULL, 0);\n    xTaskCreatePinnedToCore(buttonTask, \"ButtonTask\", 2048, NULL, 1, NULL, 0);\n    xTaskCreatePinnedToCore(endProcessTask, \"EndProcessTask\", 2048, NULL, 1, NULL, 0);\n}\n</code></pre> - Inicia la comunicaci\u00f3n serial a 9600 baudios. - Configura el pin del bot\u00f3n como entrada con resistencia pull-up. - Crea cuatro tareas fijadas al n\u00facleo 0:   - Dos instancias de <code>motorTask</code> para los motores X e Y con sus par\u00e1metros.   - Una tarea para el bot\u00f3n y otra para el control del proceso. - Cada tarea tiene 2048 bytes de pila y prioridad 1.</p>"},{"location":"content/p4/#8-funcion-loop","title":"8. Funci\u00f3n <code>loop</code>","text":"<p><pre><code>void loop() {\n    vTaskDelay(1 / portTICK_PERIOD_MS);\n}\n</code></pre> - Mantiene el programa en ejecuci\u00f3n con un retardo m\u00ednimo, ya que FreeRTOS maneja las tareas.</p>"},{"location":"content/p4/#flujo-de-ejecucion","title":"Flujo de Ejecuci\u00f3n","text":"<ol> <li>Inicio: El <code>setup()</code> configura el sistema y lanza las tareas.</li> <li>Bot\u00f3n: Al presionarse, <code>buttonTask</code> activa los estados de los motores.</li> <li>Movimiento: Cada <code>motorTask</code> configura sus pines y mueve su motor seg\u00fan <code>counterMoves</code> (300/400 pasos en el primer ciclo, 200/300 en el segundo).</li> <li>Finalizaci\u00f3n: Cuando ambos motores terminan, <code>endProcessTask</code> imprime un mensaje, espera 2 segundos, incrementa el contador y reinicia el ciclo.</li> <li>Repetici\u00f3n: El proceso se repite hasta que <code>counterMoves</code> excede 1, momento en que el sistema espera una nueva presi\u00f3n del bot\u00f3n.</li> </ol> <p>Este dise\u00f1o aprovecha la concurrencia de FreeRTOS para manejar los motores de forma independiente y eficiente.</p>"},{"location":"content/p5/","title":"Control Remoto de Motores Paso a Paso mediante MQTT y FreeRTOS","text":"<p>El siguiente c\u00f3digo es una implementaci\u00f3n para un microcontrolador ESP32 que combina el sistema operativo en tiempo real FreeRTOS con conectividad WiFi y el protocolo MQTT para controlar dos motores paso a paso de manera remota. Este programa permite recibir comandos en formato JSON a trav\u00e9s del topic MQTT <code>\"motor/control\"</code>, especificando la cantidad de pasos y la direcci\u00f3n de cada motor (X e Y). Los motores comparten un pin de control <code>ENABLE</code> (pin 10), que se activa al recibir un comando y se desactiva solo cuando ambos motores han completado sus movimientos. El sistema utiliza tareas concurrentes para manejar los motores, la comunicaci\u00f3n MQTT y el control del pin <code>ENABLE</code>, enviando notificaciones de estado al topic <code>\"motor/status\"</code>. Est\u00e1 dise\u00f1ado para ser compatible con entornos simulados como Wokwi (usando la red \"Wokwi-GUEST\") y puede adaptarse a redes f\u00edsicas como \"EstudiantesUSB\".</p> <p>Este programa es ideal para aplicaciones de automatizaci\u00f3n donde se requiere un control preciso y remoto de motores, como en rob\u00f3tica, impresoras 3D o sistemas CNC. La integraci\u00f3n de MQTT proporciona flexibilidad para interactuar con el sistema desde cualquier dispositivo conectado al broker (en este caso, <code>broker.emqx.io</code>), mientras que FreeRTOS asegura una ejecuci\u00f3n eficiente y coordinada de las tareas.</p>"},{"location":"content/p5/#explicacion-detallada","title":"Explicaci\u00f3n Detallada","text":""},{"location":"content/p5/#1-librerias-y-configuracion-inicial","title":"1. Librer\u00edas y Configuraci\u00f3n Inicial","text":"<p><pre><code>#include &lt;Arduino.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n#include &lt;ArduinoJson.h&gt;\n</code></pre> - Librer\u00edas: Se incluyen las necesarias para funciones b\u00e1sicas de Arduino, FreeRTOS (gesti\u00f3n de tareas), WiFi (conectividad), MQTT (<code>PubSubClient</code> para comunicaci\u00f3n), y <code>ArduinoJson</code> (parsing de mensajes JSON).</p> <p><pre><code>const char* ssid = \"Wokwi-GUEST\";\nconst char* password = \"\";\n// const char* ssid = \"EstudiantesUSB\";\n// const char* password = \"USB367ud14nt35\";\nconst char* mqtt_server = \"broker.emqx.io\";\nconst int mqtt_port = 1883;\nconst char* mqtt_user = \"\";\nconst char* mqtt_password = \"\";\nconst int enablePin = 10;\n</code></pre> - Configuraci\u00f3n: Define la red WiFi por defecto como \"Wokwi-GUEST\" (sin contrase\u00f1a, para simulaci\u00f3n) con una alternativa comentada para \"EstudiantesUSB\". El broker MQTT es <code>broker.emqx.io</code> (p\u00fablico), y el pin <code>ENABLE</code> se establece en 10 para controlar ambos motores.</p>"},{"location":"content/p5/#2-estructura-y-variables-globales","title":"2. Estructura y Variables Globales","text":"<p><pre><code>typedef struct {\n    int stepPin;\n    int dirPin;\n    volatile bool* state;\n    volatile int steps;\n    volatile int direction;\n} MotorParams;\n\nbool stateX = false;\nbool stateY = false;\nMotorParams motorX = {4, 5, &amp;stateX, 0, 0};\nMotorParams motorY = {6, 7, &amp;stateY, 0, 0};\n</code></pre> - <code>MotorParams</code>: Estructura que encapsula los par\u00e1metros de cada motor: pines de paso (<code>stepPin</code>) y direcci\u00f3n (<code>dirPin</code>), un puntero al estado (<code>state</code>), pasos a realizar (<code>steps</code>), y direcci\u00f3n (<code>direction</code>). Las variables son <code>volatile</code> porque se modifican entre tareas. - Variables: <code>stateX</code> y <code>stateY</code> controlan si cada motor debe moverse; <code>motorX</code> y <code>motorY</code> se inicializan con pines espec\u00edficos y valores iniciales en 0.</p>"},{"location":"content/p5/#3-funciones-de-conexion","title":"3. Funciones de Conexi\u00f3n","text":"<p><pre><code>void setupWiFi() {\n    Serial.println(\"Conectando a WiFi...\");\n    WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.println(\"\\nConectado a WiFi\");\n}\n</code></pre> - WiFi: Conecta el ESP32 a la red especificada, mostrando el progreso en el monitor serial.</p> <p><pre><code>void reconnect() {\n    while (!client.connected()) {\n        // ... (intentos de conexi\u00f3n MQTT)\n    }\n}\n</code></pre> - MQTT: Reintenta la conexi\u00f3n al broker MQTT con un ID de cliente \u00fanico, suscribi\u00e9ndose a <code>\"motor/control\"</code> y publicando \"Conectado\" al establecerse.</p>"},{"location":"content/p5/#4-callback-mqtt","title":"4. Callback MQTT","text":"<p><pre><code>void callback(char* topic, byte* payload, unsigned int length) {\n    // Construir mensaje\n    if (String(topic) == \"motor/control\") {\n        StaticJsonDocument&lt;200&gt; doc;\n        DeserializationError error = deserializeJson(doc, message);\n        if (!error) {\n            digitalWrite(enablePin, LOW); // Habilitar motores\n            if (doc.containsKey(\"motorX\")) {\n                motorX.steps = doc[\"motorX\"][\"steps\"];\n                motorX.direction = doc[\"motorX\"][\"direction\"];\n                stateX = true;\n            }\n            if (doc.containsKey(\"motorY\")) {\n                motorY.steps = doc[\"motorY\"][\"steps\"];\n                motorY.direction = doc[\"motorY\"][\"direction\"];\n                stateY = true;\n            }\n            client.publish(\"motor/status\", \"Comando recibido\");\n        }\n    }\n}\n</code></pre> - Funci\u00f3n: Procesa mensajes en <code>\"motor/control\"</code>, parseando JSON para extraer pasos y direcci\u00f3n. Activa <code>enablePin</code> (LOW) y configura los motores seg\u00fan el comando recibido.</p>"},{"location":"content/p5/#5-tareas","title":"5. Tareas","text":"<p><pre><code>void motorTask(void* pvParameters) {\n    MotorParams* params = (MotorParams*)pvParameters;\n    pinMode(params-&gt;stepPin, OUTPUT);\n    pinMode(params-&gt;dirPin, OUTPUT);\n    while (true) {\n        if (*(params-&gt;state)) {\n            digitalWrite(params-&gt;dirPin, params-&gt;direction);\n            for (int i = 0; i &lt; params-&gt;steps; i++) {\n                digitalWrite(params-&gt;stepPin, HIGH);\n                vTaskDelay(2 / portTICK_PERIOD_MS);\n                digitalWrite(params-&gt;stepPin, LOW);\n                vTaskDelay(2 / portTICK_PERIOD_MS);\n            }\n            *(params-&gt;state) = false;\n            String status = \"Motor \" + String((params-&gt;stepPin == motorX.stepPin) ? \"X\" : \"Y\") + \" detenido\";\n            client.publish(\"motor/status\", status.c_str());\n        }\n        vTaskDelay(1 / portTICK_PERIOD_MS);\n    }\n}\n</code></pre> - Motores: Configura los pines y ejecuta el movimiento cuando el estado es <code>true</code>, notificando al terminar.</p> <p><pre><code>void mqttTask(void* pvParameters) {\n    while (true) {\n        if (!client.connected()) reconnect();\n        client.loop();\n        vTaskDelay(10 / portTICK_PERIOD_MS);\n    }\n}\n</code></pre> - MQTT: Mantiene la conexi\u00f3n y procesa mensajes.</p> <p><pre><code>void enableControlTask(void* pvParameters) {\n    while (true) {\n        if (!stateX &amp;&amp; !stateY) digitalWrite(enablePin, HIGH);\n        vTaskDelay(1 / portTICK_PERIOD_MS);\n    }\n}\n</code></pre> - ENABLE: Desactiva el pin <code>ENABLE</code> (HIGH) solo cuando ambos motores han terminado.</p>"},{"location":"content/p5/#6-setup-y-loop","title":"6. Setup y Loop","text":"<p><pre><code>void setup() {\n    Serial.begin(9600);\n    digitalWrite(enablePin, HIGH);\n    pinMode(enablePin, OUTPUT);\n    setupWiFi();\n    client.setServer(mqtt_server, mqtt_port);\n    client.setCallback(callback);\n    xTaskCreatePinnedToCore(motorTask, \"MotorXTask\", 2048, &amp;motorX, 1, NULL, 0);\n    xTaskCreatePinnedToCore(motorTask, \"MotorYTask\", 2048, &amp;motorY, 1, NULL, 0);\n    xTaskCreatePinnedToCore(mqttTask, \"MqttTask\", 4096, NULL, 1, NULL, 0);\n    xTaskCreatePinnedToCore(enableControlTask, \"EnableControlTask\", 2048, NULL, 1, NULL, 0);\n}\nvoid loop() {\n    vTaskDelay(1 / portTICK_PERIOD_MS);\n}\n</code></pre> - Setup: Inicializa el sistema y lanza las tareas. - Loop: Mantiene FreeRTOS activo.</p>"},{"location":"content/p5/#7-flujo","title":"7. Flujo","text":"<ul> <li>Recibe comando MQTT \u2192 Habilita <code>ENABLE</code> \u2192 Mueve motores \u2192 Desactiva <code>ENABLE</code> cuando ambos terminan.</li> </ul>"},{"location":"content/p5/#8-ejemplo","title":"8. Ejemplo","text":"<pre><code>{\n  \"motorX\": {\"steps\": 300, \"direction\": 1},\n  \"motorY\": {\"steps\": 400, \"direction\": 1}\n}\n</code></pre>"},{"location":"content/p5/#codigo-completo","title":"Codigo completo","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n#include &lt;ArduinoJson.h&gt;\n\n// Configuraci\u00f3n de WiFi\nconst char* ssid = \"EstudiantesUSB\";\nconst char* password = \"USB367ud14nt35\";\n\n// Configuraci\u00f3n de MQTT\nconst char* mqtt_server = \"broker.emqx.io\";\nconst int mqtt_port = 1883;\nconst char* mqtt_user = \"\";\nconst char* mqtt_password = \"\";\n\n// Pin ENABLE compartido para ambos motores\nconst int enablePin = 10;\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\n// Estructura para par\u00e1metros del motor\ntypedef struct {\n    int stepPin;\n    int dirPin;\n    volatile bool* state;\n    volatile int steps;    // Pasos a realizar (actualizado por MQTT)\n    volatile int direction; // Direcci\u00f3n (0 o 1, actualizado por MQTT)\n} MotorParams;\n\nbool stateX = false;\nbool stateY = false;\n\n// Par\u00e1metros de los motores\nMotorParams motorX = {4, 5, &amp;stateX, 0, 0};\nMotorParams motorY = {6, 7, &amp;stateY, 0, 0};\n\n// Funci\u00f3n para conectar a WiFi\nvoid setupWiFi() {\n    Serial.println(\"Conectando a WiFi...\");\n    WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.println(\"\\nConectado a WiFi\");\n}\n\n// Callback para mensajes MQTT\nvoid callback(char* topic, byte* payload, unsigned int length) {\n    String message;\n    for (unsigned int i = 0; i &lt; length; i++) {\n        message += (char)payload[i];\n    }\n\n    Serial.print(\"Mensaje recibido en topic [\");\n    Serial.print(topic);\n    Serial.print(\"]: \");\n    Serial.println(message);\n\n    if (String(topic) == \"motor/control\") {\n        StaticJsonDocument&lt;200&gt; doc;\n        DeserializationError error = deserializeJson(doc, message);\n\n        if (error) {\n            Serial.print(\"Error al parsear JSON: \");\n            Serial.println(error.c_str());\n            client.publish(\"motor/status\", \"Error en JSON\");\n            return;\n        }\n\n        // Habilitar motores antes de procesar el comando\n        digitalWrite(enablePin, LOW);\n\n        // Extraer pasos y direcci\u00f3n para motor X\n        if (doc.containsKey(\"motorX\")) {\n            motorX.steps = doc[\"motorX\"][\"steps\"];\n            motorX.direction = doc[\"motorX\"][\"direction\"];\n            stateX = true;\n        }\n\n        // Extraer pasos y direcci\u00f3n para motor Y\n        if (doc.containsKey(\"motorY\")) {\n            motorY.steps = doc[\"motorY\"][\"steps\"];\n            motorY.direction = doc[\"motorY\"][\"direction\"];\n            stateY = true;\n        }\n\n        client.publish(\"motor/status\", \"Comando recibido\");\n    }\n}\n\n// Reconexi\u00f3n a MQTT\nvoid reconnect() {\n    while (!client.connected()) {\n        Serial.print(\"Conectando a MQTT...\");\n        String clientId = \"ESP32Client-\";\n        clientId += String(random(0xffff), HEX);\n\n        if (client.connect(clientId.c_str(), mqtt_user, mqtt_password)) {\n            Serial.println(\"conectado\");\n            client.subscribe(\"motor/control\");\n            client.publish(\"motor/status\", \"Conectado\");\n        } else {\n            Serial.print(\"fall\u00f3, rc=\");\n            Serial.print(client.state());\n            Serial.println(\" intentando de nuevo en 5 segundos\");\n            delay(5000);\n        }\n    }\n}\n\n// Tarea gen\u00e9rica para controlar motores\nvoid motorTask(void* pvParameters) {\n    MotorParams* params = (MotorParams*)pvParameters;\n\n    pinMode(params-&gt;stepPin, OUTPUT);\n    pinMode(params-&gt;dirPin, OUTPUT);\n\n    while (true) {\n        if (*(params-&gt;state)) {\n            digitalWrite(params-&gt;dirPin, params-&gt;direction);\n            for (int i = 0; i &lt; params-&gt;steps; i++) {\n                digitalWrite(params-&gt;stepPin, HIGH);\n                vTaskDelay(2 / portTICK_PERIOD_MS);\n                digitalWrite(params-&gt;stepPin, LOW);\n                vTaskDelay(2 / portTICK_PERIOD_MS);\n            }\n\n            *(params-&gt;state) = false;\n            String status = \"Motor \";\n            status += (params-&gt;stepPin == motorX.stepPin) ? \"X\" : \"Y\";\n            status += \" detenido\";\n            client.publish(\"motor/status\", status.c_str());\n        }\n        vTaskDelay(1 / portTICK_PERIOD_MS);\n    }\n}\n\n// Tarea para manejar MQTT\nvoid mqttTask(void* pvParameters) {\n    while (true) {\n        if (!client.connected()) {\n            reconnect();\n        }\n        client.loop();\n        vTaskDelay(10 / portTICK_PERIOD_MS);\n    }\n}\n\n// Tarea para controlar el pin ENABLE\nvoid enableControlTask(void* pvParameters) {\n    while (true) {\n        // Deshabilitar ENABLE solo cuando ambos motores han terminado\n        if (!stateX &amp;&amp; !stateY) {\n            digitalWrite(enablePin, HIGH);\n        }\n        vTaskDelay(1 / portTICK_PERIOD_MS);\n    }\n}\n\nvoid setup() {\n    Serial.begin(9600);\n    digitalWrite(enablePin, HIGH); // Motores deshabilitados al inicio\n    pinMode(enablePin, OUTPUT);    // Configurar en setup\n    setupWiFi();\n    client.setServer(mqtt_server, mqtt_port);\n    client.setCallback(callback);\n\n    xTaskCreatePinnedToCore(motorTask, \"MotorXTask\", 2048, &amp;motorX, 1, NULL, 0);\n    xTaskCreatePinnedToCore(motorTask, \"MotorYTask\", 2048, &amp;motorY, 1, NULL, 0);\n    xTaskCreatePinnedToCore(mqttTask, \"MqttTask\", 4096, NULL, 1, NULL, 0);\n    xTaskCreatePinnedToCore(enableControlTask, \"EnableControlTask\", 2048, NULL, 1, NULL, 0);\n}\n\nvoid loop() {\n    vTaskDelay(1 / portTICK_PERIOD_MS);\n}\n</code></pre>"},{"location":"content/p6/","title":"Ejemplo Control Motores Paso a Paso por mil\u00edmetros","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n\nint stepX = 4;\nint dirX = 5;\nint stepY = 6;\nint dirY = 7;\nint btnStart = 2;\nbool stateX = false;\nbool stateY = false;\nbool start = false;\nint counterMoves = 0;\nint mmR = 42;  //200steps -&gt; 42mm\nint enable = 10;\n\n//Mover el motor X\nvoid moveX(int dir, int steps) {\n  digitalWrite(dirX, dir);\n  for (int i = 0; i &lt; steps; i++) {\n    digitalWrite(stepX, HIGH);\n    vTaskDelay(10 / portTICK_PERIOD_MS);\n    digitalWrite(stepX, LOW);\n    vTaskDelay(10 / portTICK_PERIOD_MS);\n  }\n}\n\n//Mover el motor Y\nvoid moveY(int dir, int steps) {\n  digitalWrite(dirY, dir);\n  for (int i = 0; i &lt; steps; i++) {\n    digitalWrite(stepY, HIGH);\n    vTaskDelay(10 / portTICK_PERIOD_MS);\n    digitalWrite(stepY, LOW);\n    vTaskDelay(10 / portTICK_PERIOD_MS);\n  }\n}\n\n//MoveXmm\nvoid moveXmm(int dir, int mm) {\n  int steps = mm * 200 / mmR;\n  moveX(dir, steps);\n}\n\n//MoveXmm\nvoid moveYmm(int dir, int mm) {\n  int steps = mm * 200 / mmR;\n  moveY(dir, steps);\n}\n\n// Tarea para controlar el motor X\nvoid motorXTask(void *pvParameters) {\n  while (true) {\n    if (stateX == true) {\n      if (counterMoves == 0) {\n        moveXmm(1, 42);\n      }\n      if (counterMoves == 1) {\n        moveX(0, 84);\n      }\n\n      stateX = false;\n    }\n    vTaskDelay(1 / portTICK_PERIOD_MS);\n  }\n}\n\n// Tarea para controlar el motor Y\nvoid motorYTask(void *pvParameters) {\n  while (true) {\n    if (stateY == true) {\n      if (counterMoves == 0) {\n        moveYmm(1, 126);\n      }\n      if (counterMoves == 1) {\n        moveYmm(0, 42);\n      }\n      stateY = false;\n    }\n    vTaskDelay(1 / portTICK_PERIOD_MS);\n  }\n}\n\n// Tarea para controlar el bot\u00f3n\nvoid buttonTask(void *pvParameters) {\n  while (true) {\n    if (digitalRead(btnStart) == LOW) {\n      start = true;\n      stateX = true;\n      stateY = true;\n    }\n    vTaskDelay(1 / portTICK_PERIOD_MS);\n  }\n}\n\n// Tarea para mesajes puerto serial\nvoid endProcessTask(void *pvParameters) {\n  while (true) {\n    if (start == true) {\n      if (stateX == false &amp;&amp; stateY == false) {\n        Serial.println(\"Motor XY off\");\n        vTaskDelay(2000 / portTICK_PERIOD_MS);\n        counterMoves++;\n        stateX = true;\n        stateY = true;\n      }\n    }\n    vTaskDelay(1 / portTICK_PERIOD_MS);\n  }\n}\n\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(stepX, OUTPUT);\n  pinMode(dirX, OUTPUT);\n  pinMode(stepY, OUTPUT);\n  pinMode(dirY, OUTPUT);\n  pinMode(enable, OUTPUT);\n  pinMode(btnStart, INPUT_PULLUP);\n  digitalWrite(enable, LOW)\n  xTaskCreatePinnedToCore(motorXTask, \"MotorXTask\", 2048, NULL, 1, NULL, 0);\n  xTaskCreatePinnedToCore(motorYTask, \"MotorYTask\", 2048, NULL, 1, NULL, 0);\n  xTaskCreatePinnedToCore(buttonTask, \"ButtonTask\", 2048, NULL, 1, NULL, 0);\n  xTaskCreatePinnedToCore(endProcessTask, \"EndProcessTask\", 2048, NULL, 1, NULL, 0);\n}\n\nvoid loop() {\n  vTaskDelay(1 / portTICK_PERIOD_MS);\n}\n</code></pre>"},{"location":"content/p7/","title":"T\u00edtulo: Control de Motores Paso a Paso mediante MQTT y Comandos Serial en ESP32-C3","text":""},{"location":"content/p7/#introduccion","title":"Introducci\u00f3n","text":"<p>Este c\u00f3digo implementa un sistema de control para motores paso a paso utilizando una placa ESP32-C3. El sistema permite enviar comandos tanto a trav\u00e9s de mensajes MQTT como mediante una interfaz serial. Los motores pueden moverse en direcciones espec\u00edficas (arriba, abajo, izquierda, derecha) o desplazarse una distancia espec\u00edfica en mil\u00edmetros. </p> <p>El programa utiliza las bibliotecas <code>WiFi.h</code> para la conexi\u00f3n inal\u00e1mbrica, <code>PubSubClient.h</code> para la comunicaci\u00f3n MQTT y <code>ArduinoJson.h</code> para formatear los datos enviados a trav\u00e9s del protocolo MQTT. Adem\u00e1s, se incluyen funciones para procesar comandos recibidos desde el puerto serial, lo que facilita la interacci\u00f3n directa con el dispositivo.</p>"},{"location":"content/p7/#codigo-fuente","title":"C\u00f3digo Fuente","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n#include &lt;ArduinoJson.h&gt;\n\n// Configuraci\u00f3n de WiFi\nconst char* ssid = \"EstudiantesUSB\";\nconst char* password = \"USB367ud14nt35\";\n\n// Configuraci\u00f3n de MQTT\nconst char* mqtt_server = \"broker.emqx.io\";\nconst int mqtt_port = 1883;\nconst char* mqtt_user = \"\";\nconst char* mqtt_password = \"\";\n\n// T\u00f3picos MQTT\nconst char* control_topic = \"motor/control\";\nconst char* status_topic = \"motor/status\";\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\n// Factor de conversi\u00f3n: pasos por mil\u00edmetro\nconst float steps_per_mm = 80.0;  // Ajustar seg\u00fan la configuraci\u00f3n del motor\n\n// Funci\u00f3n para conectar a WiFi\nvoid setupWiFi() {\n  Serial.println(\"Conectando a WiFi...\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nConectado a WiFi\");\n}\n\n// Callback para recibir mensajes del esclavo\nvoid callback(char* topic, byte* payload, unsigned int length) {\n  String message;\n  for (unsigned int i = 0; i &lt; length; i++) {\n    message += (char)payload[i];\n  }\n  Serial.print(\"Estado recibido [\");\n  Serial.print(topic);\n  Serial.print(\"]: \");\n  Serial.println(message);\n}\n\n// Reconexi\u00f3n a MQTT\nvoid reconnect() {\n  while (!client.connected()) {\n    Serial.print(\"Conectando a MQTT...\");\n    String clientId = \"ESP32C3Controller-\";\n    clientId += String(random(0xffff), HEX);\n\n    if (client.connect(clientId.c_str(), mqtt_user, mqtt_password)) {\n      Serial.println(\"conectado\");\n      client.subscribe(status_topic);\n      client.publish(status_topic, \"Controlador conectado\");\n    } else {\n      Serial.print(\"fall\u00f3, rc=\");\n      Serial.print(client.state());\n      Serial.println(\" intentando de nuevo en 5 segundos\");\n      delay(5000);\n    }\n  }\n}\n\n// Funci\u00f3n para enviar comando a los motores\nvoid sendMotorCommand(int motorXSteps, int motorXDir, int motorYSteps, int motorYDir) {\n  StaticJsonDocument&lt;200&gt; doc;\n\n  if (motorXSteps != 0) {\n    doc[\"motorX\"][\"steps\"] = abs(motorXSteps);\n    doc[\"motorX\"][\"direction\"] = motorXDir;  // Direcci\u00f3n expl\u00edcita\n  }\n\n  if (motorYSteps != 0) {\n    doc[\"motorY\"][\"steps\"] = abs(motorYSteps);\n    doc[\"motorY\"][\"direction\"] = motorYDir;  // Direcci\u00f3n expl\u00edcita\n  }\n\n  char buffer[256];\n  serializeJson(doc, buffer);\n  client.publish(control_topic, buffer);\n  Serial.print(\"Comando enviado: \");\n  Serial.println(buffer);\n}\n\n// Procesar comandos Serial\nvoid processSerialCommand() {\n  if (Serial.available() &gt; 0) {\n    String command = Serial.readStringUntil('\\n');\n    command.trim();\n\n    // Movimientos b\u00e1sicos con direcciones fijas\n    if (command == \"up\") sendMotorCommand(0, 0, 200, 1);          // Y positivo\n    else if (command == \"down\") sendMotorCommand(0, 0, 200, 0);   // Y negativo\n    else if (command == \"left\") sendMotorCommand(200, 0, 0, 0);   // X negativo\n    else if (command == \"right\") sendMotorCommand(200, 1, 0, 0);  // X positivo\n\n    // Movimientos en mil\u00edmetros\n    else if (command.startsWith(\"xmove_mm\")) {\n      //TODO\n    } else if (command.startsWith(\"ymove_mm\")) {\n      //TODO\n    }\n    // Comando no reconocido\n    else {\n      Serial.println(\"Comando no reconocido. Comandos disponibles:\");\n      Serial.println(\"up, down, left, right\");\n      Serial.println(\"xmove_mm DISTANCE, ymove_mm DISTANCE\");\n      Serial.println(\"move_mm X Y\");\n    }\n  }\n}\n\nvoid setup() {\n  Serial.begin(9600);\n\n  setupWiFi();\n  client.setServer(mqtt_server, mqtt_port);\n  client.setCallback(callback);\n\n  Serial.println(\"Controlador ESP32-C3 listo. Comandos disponibles:\");\n  Serial.println(\"up, down, left, right\");\n  Serial.println(\"xmove_mm DISTANCE, ymove_mm DISTANCE\");\n  Serial.println(\"move_mm X Y\");\n}\n\nvoid loop() {\n  if (!client.connected()) {\n    reconnect();\n  }\n  client.loop();\n\n  // Control por Serial\n  processSerialCommand();\n\n  delay(10);\n}\n</code></pre>"},{"location":"content/p7/#explicacion-general-del-codigo","title":"Explicaci\u00f3n General del C\u00f3digo","text":"<ol> <li>Configuraci\u00f3n Inicial:</li> <li>Se define la configuraci\u00f3n de WiFi (SSID y contrase\u00f1a) y los par\u00e1metros del broker MQTT (servidor, puerto, credenciales).</li> <li> <p>Se especifican los t\u00f3picos MQTT para el control (<code>motor/control</code>) y el estado (<code>motor/status</code>).</p> </li> <li> <p>Conexi\u00f3n a WiFi:</p> </li> <li> <p>La funci\u00f3n <code>setupWiFi()</code> gestiona la conexi\u00f3n a la red WiFi. Muestra mensajes en el monitor serial para indicar el progreso.</p> </li> <li> <p>Comunicaci\u00f3n MQTT:</p> </li> <li>La funci\u00f3n <code>reconnect()</code> intenta conectarse al broker MQTT hasta que lo logra. Una vez conectado, se suscribe al t\u00f3pico <code>motor/status</code> y publica un mensaje inicial.</li> <li> <p>La funci\u00f3n <code>callback()</code> maneja los mensajes recibidos desde el broker MQTT.</p> </li> <li> <p>Env\u00edo de Comandos a Motores:</p> </li> <li> <p>La funci\u00f3n <code>sendMotorCommand()</code> construye un mensaje JSON con los pasos y la direcci\u00f3n para cada motor (X e Y). Este mensaje se publica en el t\u00f3pico <code>motor/control</code>.</p> </li> <li> <p>Procesamiento de Comandos Serial:</p> </li> <li> <p>La funci\u00f3n <code>processSerialCommand()</code> interpreta los comandos ingresados por el usuario a trav\u00e9s del monitor serial. Soporta movimientos b\u00e1sicos (<code>up</code>, <code>down</code>, <code>left</code>, <code>right</code>) y movimientos en mil\u00edmetros (<code>xmove_mm</code>, <code>ymove_mm</code>, <code>move_mm</code>).</p> </li> <li> <p>Bucle Principal:</p> </li> <li>En el bucle principal (<code>loop()</code>), se verifica la conexi\u00f3n MQTT y se procesan los comandos serial.</li> </ol>"},{"location":"content/p7/#ejemplos-de-uso","title":"Ejemplos de Uso","text":""},{"location":"content/p7/#1-movimientos-basicos","title":"1. Movimientos B\u00e1sicos","text":"<ul> <li>Comando: <code>up</code></li> <li>Acci\u00f3n: Mueve el motor Y hacia arriba (direcci\u00f3n positiva) 200 pasos.</li> <li>Comando: <code>down</code></li> <li>Acci\u00f3n: Mueve el motor Y hacia abajo (direcci\u00f3n negativa) 200 pasos.</li> <li>Comando: <code>left</code></li> <li>Acci\u00f3n: Mueve el motor X hacia la izquierda (direcci\u00f3n negativa) 200 pasos.</li> <li>Comando: <code>right</code></li> <li>Acci\u00f3n: Mueve el motor X hacia la derecha (direcci\u00f3n positiva) 200 pasos.</li> </ul>"},{"location":"content/p7/#2-movimientos-en-milimetros","title":"2. Movimientos en Mil\u00edmetros","text":"<ul> <li>Comando: <code>xmove_mm 10</code></li> <li>Acci\u00f3n: Mueve el motor X una distancia de 10 mm en la direcci\u00f3n actual.</li> <li>Comando: <code>ymove_mm -5</code></li> <li>Acci\u00f3n: Mueve el motor Y una distancia de 5 mm en direcci\u00f3n negativa.</li> <li>Comando: <code>move_mm 10 -5</code></li> <li>Acci\u00f3n: Mueve el motor X 10 mm en direcci\u00f3n positiva y el motor Y 5 mm en direcci\u00f3n negativa simult\u00e1neamente.</li> </ul>"},{"location":"content/p7/#indicaciones-para-realizar-todos","title":"Indicaciones para Realizar TODOs","text":""},{"location":"content/p7/#todo-1-implementar-xmove_mm","title":"TODO 1: Implementar <code>xmove_mm</code>","text":"<p>Descripci\u00f3n: Procesar el comando <code>xmove_mm DISTANCE</code> para mover el motor X una distancia espec\u00edfica en mil\u00edmetros.</p>"},{"location":"content/p7/#pasos-a-seguir","title":"Pasos a Seguir:","text":"<ol> <li>Identificar el Comando:</li> <li> <p>Aseg\u00farate de que el comando comience con <code>\"xmove_mm\"</code>. Puedes usar la funci\u00f3n <code>startsWith()</code> para verificar esto.</p> </li> <li> <p>Extraer la Distancia:</p> </li> <li>Utiliza la funci\u00f3n <code>substring()</code> para extraer la parte del comando que contiene la distancia. Por ejemplo, si el comando es <code>\"xmove_mm 10\"</code>, necesitas extraer <code>\"10\"</code>.</li> <li> <p>Convierte el valor extra\u00eddo a un entero usando <code>toInt()</code>.</p> </li> <li> <p>Convertir Mil\u00edmetros a Pasos:</p> </li> <li>Multiplica la distancia en mil\u00edmetros por el factor <code>steps_per_mm</code> para obtener el n\u00famero de pasos requeridos.</li> <li> <p>Usa la funci\u00f3n <code>abs()</code> para asegurarte de que el n\u00famero de pasos sea positivo, independientemente del signo de la distancia.</p> </li> <li> <p>Determinar la Direcci\u00f3n:</p> </li> <li> <p>Si la distancia es positiva, la direcci\u00f3n ser\u00e1 <code>1</code> (hacia adelante). Si es negativa, la direcci\u00f3n ser\u00e1 <code>0</code> (hacia atr\u00e1s).</p> </li> <li> <p>Enviar el Comando al Motor:</p> </li> <li>Llama a la funci\u00f3n <code>sendMotorCommand()</code> con los valores calculados para los pasos y la direcci\u00f3n del motor X. Los valores para el motor Y deben ser <code>0</code> ya que no se mueve.</li> </ol>"},{"location":"content/p7/#todo-2-implementar-ymove_mm","title":"TODO 2: Implementar <code>ymove_mm</code>","text":"<p>Descripci\u00f3n: Procesar el comando <code>ymove_mm DISTANCE</code> para mover el motor Y una distancia espec\u00edfica en mil\u00edmetros.</p>"},{"location":"content/p7/#pasos-a-seguir_1","title":"Pasos a Seguir:","text":"<ol> <li>Identificar el Comando:</li> <li> <p>Verifica que el comando comience con <code>\"ymove_mm\"</code> usando <code>startsWith()</code>.</p> </li> <li> <p>Extraer la Distancia:</p> </li> <li>Usa <code>substring()</code> para extraer la parte del comando que contiene la distancia.</li> <li> <p>Convierte el valor extra\u00eddo a un entero usando <code>toInt()</code>.</p> </li> <li> <p>Convertir Mil\u00edmetros a Pasos:</p> </li> <li> <p>Multiplica la distancia en mil\u00edmetros por el factor <code>steps_per_mm</code> para obtener el n\u00famero de pasos requeridos.</p> </li> <li> <p>Determinar la Direcci\u00f3n:</p> </li> <li> <p>Si la distancia es positiva, la direcci\u00f3n ser\u00e1 <code>1</code>. Si es negativa, la direcci\u00f3n ser\u00e1 <code>0</code>.</p> </li> <li> <p>Enviar el Comando al Motor:</p> </li> <li>Llama a la funci\u00f3n <code>sendMotorCommand()</code> con los valores calculados para los pasos y la direcci\u00f3n del motor Y. Los valores para el motor X deben ser <code>0</code> ya que no se mueve.</li> </ol>"},{"location":"content/p7/#comandos-enviados-por-la-terminal","title":"Comandos Enviados por la Terminal","text":"<pre><code>up\ndown\nleft\nright\nxmove_mm 10\nxmove_mm -5\nymove_mm 7\nymove_mm -3\nmove_mm 10 -5\nmove_mm -3 8\n</code></pre>"},{"location":"pi/p1/","title":"Introducci\u00f3n Proyecto Integrador","text":""},{"location":"pi/p2/","title":"Avance 1","text":""}]}